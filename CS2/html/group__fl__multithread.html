<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>FLTK 1.3.9: Multithreading support functions</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript" src="darkmode_toggle.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">FLTK 1.3.9
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('group__fl__multithread.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">Multithreading support functions</div></div>
</div><!--header-->
<div class="contents">

<p>fl multithreading support functions declared in &lt;<a class="el" href="Fl_8H.html" title="Fl static class.">FL/Fl.H</a>&gt;  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga22a404bcaf6641369e0725627d881556" id="r_ga22a404bcaf6641369e0725627d881556"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__multithread.html#ga22a404bcaf6641369e0725627d881556">Fl::awake</a> (<a class="el" href="group__callback__functions.html#ga28b44ff2052ca0b06d0da852fadd42c0">Fl_Awake_Handler</a> cb, void *message=0)</td></tr>
<tr class="memdesc:ga22a404bcaf6641369e0725627d881556"><td class="mdescLeft">&#160;</td><td class="mdescRight">See void awake(void* message=0).  <br /></td></tr>
<tr class="separator:ga22a404bcaf6641369e0725627d881556"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae9e8f440ce2ca05b047c620f75af13cb" id="r_gae9e8f440ce2ca05b047c620f75af13cb"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__multithread.html#gae9e8f440ce2ca05b047c620f75af13cb">Fl::awake</a> (void *message=0)</td></tr>
<tr class="memdesc:gae9e8f440ce2ca05b047c620f75af13cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends a message pointer to the main thread, causing any pending <a class="el" href="classFl.html#a108a84216f0b3fa1cb0c46ab7449a312" title="Waits until &quot;something happens&quot; and then returns.">Fl::wait()</a> call to terminate so that the main thread can retrieve the message and any pending redraws can be processed.  <br /></td></tr>
<tr class="separator:gae9e8f440ce2ca05b047c620f75af13cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf6f46de66cc183bc5b38cd364aca4cf2" id="r_gaf6f46de66cc183bc5b38cd364aca4cf2"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__multithread.html#gaf6f46de66cc183bc5b38cd364aca4cf2">Fl::lock</a> ()</td></tr>
<tr class="memdesc:gaf6f46de66cc183bc5b38cd364aca4cf2"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="group__fl__multithread.html#gaf6f46de66cc183bc5b38cd364aca4cf2" title="The lock() method blocks the current thread until it can safely access FLTK widgets and data.">lock()</a> method blocks the current thread until it can safely access FLTK widgets and data.  <br /></td></tr>
<tr class="separator:gaf6f46de66cc183bc5b38cd364aca4cf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga82258694ec1baf11c3756c965b2c501e" id="r_ga82258694ec1baf11c3756c965b2c501e"><td class="memItemLeft" align="right" valign="top">static void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__multithread.html#ga82258694ec1baf11c3756c965b2c501e">Fl::thread_message</a> ()</td></tr>
<tr class="memdesc:ga82258694ec1baf11c3756c965b2c501e"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="group__fl__multithread.html#ga82258694ec1baf11c3756c965b2c501e" title="The thread_message() method returns the last message that was sent from a child by the awake() method...">thread_message()</a> method returns the last message that was sent from a child by the <a class="el" href="group__fl__multithread.html#gae9e8f440ce2ca05b047c620f75af13cb" title="Sends a message pointer to the main thread, causing any pending Fl::wait() call to terminate so that ...">awake()</a> method.  <br /></td></tr>
<tr class="separator:ga82258694ec1baf11c3756c965b2c501e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2b9375cc078d9d39161e2cba520829fd" id="r_ga2b9375cc078d9d39161e2cba520829fd"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__multithread.html#ga2b9375cc078d9d39161e2cba520829fd">Fl::unlock</a> ()</td></tr>
<tr class="memdesc:ga2b9375cc078d9d39161e2cba520829fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="group__fl__multithread.html#ga2b9375cc078d9d39161e2cba520829fd" title="The unlock() method releases the lock that was set using the lock() method.">unlock()</a> method releases the lock that was set using the <a class="el" href="group__fl__multithread.html#gaf6f46de66cc183bc5b38cd364aca4cf2" title="The lock() method blocks the current thread until it can safely access FLTK widgets and data.">lock()</a> method.  <br /></td></tr>
<tr class="separator:ga2b9375cc078d9d39161e2cba520829fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>fl multithreading support functions declared in &lt;<a class="el" href="Fl_8H.html" title="Fl static class.">FL/Fl.H</a>&gt; </p>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga22a404bcaf6641369e0725627d881556" name="ga22a404bcaf6641369e0725627d881556"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga22a404bcaf6641369e0725627d881556">&#9670;&#160;</a></span>awake() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Fl::awake </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__callback__functions.html#ga28b44ff2052ca0b06d0da852fadd42c0">Fl_Awake_Handler</a>&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>See void awake(void* message=0). </p>
<p>Let the main thread know an update is pending and have it call a specific function.</p>
<p>Registers a function that will be called by the main thread during the next message handling cycle. Returns 0 if the callback function was registered, and -1 if registration failed. Over a thousand awake callbacks can be registered simultaneously.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__fl__multithread.html#gae9e8f440ce2ca05b047c620f75af13cb" title="Sends a message pointer to the main thread, causing any pending Fl::wait() call to terminate so that ...">Fl::awake</a>(void* message=0) </dd></dl>

</div>
</div>
<a id="gae9e8f440ce2ca05b047c620f75af13cb" name="gae9e8f440ce2ca05b047c620f75af13cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae9e8f440ce2ca05b047c620f75af13cb">&#9670;&#160;</a></span>awake() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Fl::awake </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>msg</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sends a message pointer to the main thread, causing any pending <a class="el" href="classFl.html#a108a84216f0b3fa1cb0c46ab7449a312" title="Waits until &quot;something happens&quot; and then returns.">Fl::wait()</a> call to terminate so that the main thread can retrieve the message and any pending redraws can be processed. </p>
<p>Multiple calls to <a class="el" href="group__fl__multithread.html#gae9e8f440ce2ca05b047c620f75af13cb" title="Sends a message pointer to the main thread, causing any pending Fl::wait() call to terminate so that ...">Fl::awake()</a> will queue multiple pointers for the main thread to process, up to a system-defined (typically several thousand) depth. The default message handler saves the last message which can be accessed using the <a class="el" href="group__fl__multithread.html#ga82258694ec1baf11c3756c965b2c501e" title="The thread_message() method returns the last message that was sent from a child by the awake() method...">Fl::thread_message()</a> function.</p>
<p>In the context of a threaded application, a call to <a class="el" href="group__fl__multithread.html#gae9e8f440ce2ca05b047c620f75af13cb" title="Sends a message pointer to the main thread, causing any pending Fl::wait() call to terminate so that ...">Fl::awake()</a> with no argument will trigger event loop handling in the main thread. Since it is not possible to call <a class="el" href="classFl.html#a08d29d807ea3874b8bb16f7457f64bdc" title="Causes all the windows that need it to be redrawn and graphics forced out through the pipes.">Fl::flush()</a> from a subsidiary thread, <a class="el" href="group__fl__multithread.html#gae9e8f440ce2ca05b047c620f75af13cb" title="Sends a message pointer to the main thread, causing any pending Fl::wait() call to terminate so that ...">Fl::awake()</a> is the best (and only, really) substitute.</p>
<p>See also: <a class="el" href="advanced.html#advanced_multithreading">Multithreading</a> </p>

</div>
</div>
<a id="gaf6f46de66cc183bc5b38cd364aca4cf2" name="gaf6f46de66cc183bc5b38cd364aca4cf2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf6f46de66cc183bc5b38cd364aca4cf2">&#9670;&#160;</a></span>lock()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Fl::lock </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The <a class="el" href="group__fl__multithread.html#gaf6f46de66cc183bc5b38cd364aca4cf2" title="The lock() method blocks the current thread until it can safely access FLTK widgets and data.">lock()</a> method blocks the current thread until it can safely access FLTK widgets and data. </p>
<p>Child threads should call this method prior to updating any widgets or accessing data. The main thread must call <a class="el" href="group__fl__multithread.html#gaf6f46de66cc183bc5b38cd364aca4cf2" title="The lock() method blocks the current thread until it can safely access FLTK widgets and data.">lock()</a> to initialize the threading support in FLTK. <a class="el" href="group__fl__multithread.html#gaf6f46de66cc183bc5b38cd364aca4cf2" title="The lock() method blocks the current thread until it can safely access FLTK widgets and data.">lock()</a> will return non-zero if threading is not available on the platform.</p>
<p>Child threads must call <a class="el" href="group__fl__multithread.html#ga2b9375cc078d9d39161e2cba520829fd" title="The unlock() method releases the lock that was set using the lock() method.">unlock()</a> when they are done accessing FLTK.</p>
<p>When the <a class="el" href="classFl.html#a108a84216f0b3fa1cb0c46ab7449a312" title="Waits until &quot;something happens&quot; and then returns.">wait()</a> method is waiting for input or timeouts, child threads are given access to FLTK. Similarly, when the main thread needs to do processing, it will wait until all child threads have called <a class="el" href="group__fl__multithread.html#ga2b9375cc078d9d39161e2cba520829fd" title="The unlock() method releases the lock that was set using the lock() method.">unlock()</a> before processing additional data.</p>
<dl class="section return"><dt>Returns</dt><dd>0 if threading is available on the platform; non-zero otherwise.</dd></dl>
<p>See also: <a class="el" href="advanced.html#advanced_multithreading">Multithreading</a> </p>

</div>
</div>
<a id="ga82258694ec1baf11c3756c965b2c501e" name="ga82258694ec1baf11c3756c965b2c501e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga82258694ec1baf11c3756c965b2c501e">&#9670;&#160;</a></span>thread_message()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void * Fl::thread_message </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The <a class="el" href="group__fl__multithread.html#ga82258694ec1baf11c3756c965b2c501e" title="The thread_message() method returns the last message that was sent from a child by the awake() method...">thread_message()</a> method returns the last message that was sent from a child by the <a class="el" href="group__fl__multithread.html#gae9e8f440ce2ca05b047c620f75af13cb" title="Sends a message pointer to the main thread, causing any pending Fl::wait() call to terminate so that ...">awake()</a> method. </p>
<p>See also: <a class="el" href="advanced.html#advanced_multithreading">Multithreading</a> </p>

</div>
</div>
<a id="ga2b9375cc078d9d39161e2cba520829fd" name="ga2b9375cc078d9d39161e2cba520829fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2b9375cc078d9d39161e2cba520829fd">&#9670;&#160;</a></span>unlock()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Fl::unlock </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The <a class="el" href="group__fl__multithread.html#ga2b9375cc078d9d39161e2cba520829fd" title="The unlock() method releases the lock that was set using the lock() method.">unlock()</a> method releases the lock that was set using the <a class="el" href="group__fl__multithread.html#gaf6f46de66cc183bc5b38cd364aca4cf2" title="The lock() method blocks the current thread until it can safely access FLTK widgets and data.">lock()</a> method. </p>
<p>Child threads should call this method as soon as they are finished accessing FLTK.</p>
<p>See also: <a class="el" href="advanced.html#advanced_multithreading">Multithreading</a> </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
