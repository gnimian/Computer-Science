<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>FLTK 1.3.9: Fl Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript" src="darkmode_toggle.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">FLTK 1.3.9
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('classFl.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="classFl-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">Fl Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>The <a class="el" href="classFl.html" title="The Fl is the FLTK global (static) class containing state information and global methods for the curr...">Fl</a> is the FLTK global (static) class containing state information and global methods for the current application.  
 <a href="classFl.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="Fl_8H_source.html">Fl.H</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a43e6e0bbbc03cad134d928d4edd48d1d" id="r_a43e6e0bbbc03cad134d928d4edd48d1d"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl.html#a43e6e0bbbc03cad134d928d4edd48d1d">Fl_Option</a> { <br />
&#160;&#160;<a class="el" href="classFl.html#a43e6e0bbbc03cad134d928d4edd48d1da0d10867528510b82613c085e6240ebf6">OPTION_ARROW_FOCUS</a> = 0
, <a class="el" href="classFl.html#a43e6e0bbbc03cad134d928d4edd48d1dade29f22fc8066222d99ea3ccebc5e655">OPTION_VISIBLE_FOCUS</a>
, <a class="el" href="classFl.html#a43e6e0bbbc03cad134d928d4edd48d1da2344bf14f80ecf5971e8aa4493a3858a">OPTION_DND_TEXT</a>
, <a class="el" href="classFl.html#a43e6e0bbbc03cad134d928d4edd48d1dae8214e42f77fe157297d61fdb818be2f">OPTION_SHOW_TOOLTIPS</a>
, <br />
&#160;&#160;<a class="el" href="classFl.html#a43e6e0bbbc03cad134d928d4edd48d1da01d530d6bc747eb0c192038eb802a8bd">OPTION_FNFC_USES_GTK</a>
, <a class="el" href="classFl.html#a43e6e0bbbc03cad134d928d4edd48d1da220ebf62255fc47e5b5f213b410e2bc5">OPTION_LAST</a>
<br />
 }</td></tr>
<tr class="memdesc:a43e6e0bbbc03cad134d928d4edd48d1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumerator for global FLTK options.  <a href="classFl.html#a43e6e0bbbc03cad134d928d4edd48d1d">More...</a><br /></td></tr>
<tr class="separator:a43e6e0bbbc03cad134d928d4edd48d1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:aeec1fc58b2ded93866e75fc0f317b284" id="r_aeec1fc58b2ded93866e75fc0f317b284"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl.html#aeec1fc58b2ded93866e75fc0f317b284">abi_check</a> (const int val=<a class="el" href="Enumerations_8H.html#a619cd27e13a15a7b1b5ead0932dd3912">FL_ABI_VERSION</a>)</td></tr>
<tr class="memdesc:aeec1fc58b2ded93866e75fc0f317b284"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the runtime library ABI version is correct.  <br /></td></tr>
<tr class="separator:aeec1fc58b2ded93866e75fc0f317b284"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa664880d0a1fab25b7bb53803112093" id="r_aaa664880d0a1fab25b7bb53803112093"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl.html#aaa664880d0a1fab25b7bb53803112093">abi_version</a> ()</td></tr>
<tr class="memdesc:aaa664880d0a1fab25b7bb53803112093"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the compiled-in value of the FL_ABI_VERSION constant.  <br /></td></tr>
<tr class="separator:aaa664880d0a1fab25b7bb53803112093"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afff1ee2c6afa6463293a2188a44b00b5" id="r_afff1ee2c6afa6463293a2188a44b00b5"><td class="memItemLeft" align="right" valign="top"><a id="afff1ee2c6afa6463293a2188a44b00b5" name="afff1ee2c6afa6463293a2188a44b00b5"></a>
static int&#160;</td><td class="memItemRight" valign="bottom"><b>add_awake_handler_</b> (<a class="el" href="group__callback__functions.html#ga28b44ff2052ca0b06d0da852fadd42c0">Fl_Awake_Handler</a>, void *)</td></tr>
<tr class="memdesc:afff1ee2c6afa6463293a2188a44b00b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds an awake handler for use in <a class="el" href="group__fl__multithread.html#gae9e8f440ce2ca05b047c620f75af13cb" title="Sends a message pointer to the main thread, causing any pending Fl::wait() call to terminate so that ...">awake()</a>. <br /></td></tr>
<tr class="separator:afff1ee2c6afa6463293a2188a44b00b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b689a9e42582fe6e87f7c7eb1dce94f" id="r_a7b689a9e42582fe6e87f7c7eb1dce94f"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl.html#a7b689a9e42582fe6e87f7c7eb1dce94f">add_check</a> (<a class="el" href="group__callback__functions.html#ga17b5c6570394124287997166a50ff07a">Fl_Timeout_Handler</a>, void *=0)</td></tr>
<tr class="memdesc:a7b689a9e42582fe6e87f7c7eb1dce94f"><td class="mdescLeft">&#160;</td><td class="mdescRight">FLTK will call this callback just before it flushes the display and waits for events.  <br /></td></tr>
<tr class="separator:a7b689a9e42582fe6e87f7c7eb1dce94f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa01ff0cf95384f8255fa80edcbe1432d" id="r_gaa01ff0cf95384f8255fa80edcbe1432d"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__clipboard.html#gaa01ff0cf95384f8255fa80edcbe1432d">add_clipboard_notify</a> (<a class="el" href="group__callback__functions.html#gae5e26cbad23960ff7ce4d50d82c74750">Fl_Clipboard_Notify_Handler</a> <a class="el" href="group__fl__screen.html#ga0a9410a98136445bacce42b2e3ad4e84">h</a>, void *data=0)</td></tr>
<tr class="memdesc:gaa01ff0cf95384f8255fa80edcbe1432d"><td class="mdescLeft">&#160;</td><td class="mdescRight">FLTK will call the registered callback whenever there is a change to the selection buffer or the clipboard.  <br /></td></tr>
<tr class="separator:gaa01ff0cf95384f8255fa80edcbe1432d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad45d81e99587aa6115cb8a6b3d757517" id="r_ad45d81e99587aa6115cb8a6b3d757517"><td class="memItemLeft" align="right" valign="top"><a id="ad45d81e99587aa6115cb8a6b3d757517" name="ad45d81e99587aa6115cb8a6b3d757517"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><b>add_fd</b> (int fd, <a class="el" href="group__callback__functions.html#ga2cff1a51089da7653ab49bae499dfbf4">Fl_FD_Handler</a> cb, void *=0)</td></tr>
<tr class="memdesc:ad45d81e99587aa6115cb8a6b3d757517"><td class="mdescLeft">&#160;</td><td class="mdescRight">See void add_fd(int fd, int when, Fl_FD_Handler cb, void* = 0) <br /></td></tr>
<tr class="separator:ad45d81e99587aa6115cb8a6b3d757517"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a799b8278326b3c2db15687c43c11aaf6" id="r_a799b8278326b3c2db15687c43c11aaf6"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl.html#a799b8278326b3c2db15687c43c11aaf6">add_fd</a> (int fd, int when, <a class="el" href="group__callback__functions.html#ga2cff1a51089da7653ab49bae499dfbf4">Fl_FD_Handler</a> cb, void *=0)</td></tr>
<tr class="memdesc:a799b8278326b3c2db15687c43c11aaf6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds file descriptor fd to listen to.  <br /></td></tr>
<tr class="separator:a799b8278326b3c2db15687c43c11aaf6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae2d39bda7362e444afa41166c478b904" id="r_gae2d39bda7362e444afa41166c478b904"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__events.html#gae2d39bda7362e444afa41166c478b904">add_handler</a> (<a class="el" href="group__callback__functions.html#ga188f6b1dd8e78ccc91c013fe5c6bba74">Fl_Event_Handler</a> <a class="el" href="group__fl__screen.html#ga0a9410a98136445bacce42b2e3ad4e84">h</a>)</td></tr>
<tr class="memdesc:gae2d39bda7362e444afa41166c478b904"><td class="mdescLeft">&#160;</td><td class="mdescRight">Install a function to parse unrecognized events.  <br /></td></tr>
<tr class="separator:gae2d39bda7362e444afa41166c478b904"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e7a1b5d18c2f073238a8466a62a3e7a" id="r_a4e7a1b5d18c2f073238a8466a62a3e7a"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl.html#a4e7a1b5d18c2f073238a8466a62a3e7a">add_idle</a> (<a class="el" href="group__callback__functions.html#gac9d2aab1d3142308450e2da09716013e">Fl_Idle_Handler</a> cb, void *data=0)</td></tr>
<tr class="memdesc:a4e7a1b5d18c2f073238a8466a62a3e7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a callback function that is called every time by <a class="el" href="classFl.html#a108a84216f0b3fa1cb0c46ab7449a312" title="Waits until &quot;something happens&quot; and then returns.">Fl::wait()</a> and also makes it act as though the timeout is zero (this makes <a class="el" href="classFl.html#a108a84216f0b3fa1cb0c46ab7449a312" title="Waits until &quot;something happens&quot; and then returns.">Fl::wait()</a> return immediately, so if it is in a loop it is called repeatedly, and thus the idle fucntion is called repeatedly).  <br /></td></tr>
<tr class="separator:a4e7a1b5d18c2f073238a8466a62a3e7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad87427a41cb546d97236c244abaff8bd" id="r_gad87427a41cb546d97236c244abaff8bd"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__events.html#gad87427a41cb546d97236c244abaff8bd">add_system_handler</a> (<a class="el" href="group__callback__functions.html#ga0cd86d9a18073304779213e82747ac8a">Fl_System_Handler</a> <a class="el" href="group__fl__screen.html#ga0a9410a98136445bacce42b2e3ad4e84">h</a>, void *data)</td></tr>
<tr class="memdesc:gad87427a41cb546d97236c244abaff8bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Install a function to intercept system events.  <br /></td></tr>
<tr class="separator:gad87427a41cb546d97236c244abaff8bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23e63eb7cec3a27fa360e66c6e2b2e52" id="r_a23e63eb7cec3a27fa360e66c6e2b2e52"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl.html#a23e63eb7cec3a27fa360e66c6e2b2e52">add_timeout</a> (double t, <a class="el" href="group__callback__functions.html#ga17b5c6570394124287997166a50ff07a">Fl_Timeout_Handler</a>, void *=0)</td></tr>
<tr class="memdesc:a23e63eb7cec3a27fa360e66c6e2b2e52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a one-shot timeout callback.  <br /></td></tr>
<tr class="separator:a23e63eb7cec3a27fa360e66c6e2b2e52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7600b0ef3dcd4311850ab4b2988d5d6d" id="r_a7600b0ef3dcd4311850ab4b2988d5d6d"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl.html#a7600b0ef3dcd4311850ab4b2988d5d6d">api_version</a> ()</td></tr>
<tr class="memdesc:a7600b0ef3dcd4311850ab4b2988d5d6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the compiled-in value of the FL_API_VERSION constant.  <br /></td></tr>
<tr class="separator:a7600b0ef3dcd4311850ab4b2988d5d6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1576b8c9ca3e900daaa5c36ca0e7ae48" id="r_a1576b8c9ca3e900daaa5c36ca0e7ae48"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl.html#a1576b8c9ca3e900daaa5c36ca0e7ae48">arg</a> (int argc, char **argv, int &amp;i)</td></tr>
<tr class="memdesc:a1576b8c9ca3e900daaa5c36ca0e7ae48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse a single switch from <code>argv</code>, starting at word <code>i</code>.  <br /></td></tr>
<tr class="separator:a1576b8c9ca3e900daaa5c36ca0e7ae48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fb24179ad2642412f4042863fe23645" id="r_a6fb24179ad2642412f4042863fe23645"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl.html#a6fb24179ad2642412f4042863fe23645">args</a> (int argc, char **argv)</td></tr>
<tr class="memdesc:a6fb24179ad2642412f4042863fe23645"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse all command line switches matching standard FLTK options only.  <br /></td></tr>
<tr class="separator:a6fb24179ad2642412f4042863fe23645"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a115903daf3593748cdd36a5e78e74534" id="r_a115903daf3593748cdd36a5e78e74534"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl.html#a115903daf3593748cdd36a5e78e74534">args</a> (int argc, char **argv, int &amp;i, <a class="el" href="group__callback__functions.html#ga6cb5354ccaa2a6619f2408dbb5203f3b">Fl_Args_Handler</a> cb=0)</td></tr>
<tr class="memdesc:a115903daf3593748cdd36a5e78e74534"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse command line switches using the <code>cb</code> argument handler.  <br /></td></tr>
<tr class="separator:a115903daf3593748cdd36a5e78e74534"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga22a404bcaf6641369e0725627d881556" id="r_ga22a404bcaf6641369e0725627d881556"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__multithread.html#ga22a404bcaf6641369e0725627d881556">awake</a> (<a class="el" href="group__callback__functions.html#ga28b44ff2052ca0b06d0da852fadd42c0">Fl_Awake_Handler</a> cb, void *message=0)</td></tr>
<tr class="memdesc:ga22a404bcaf6641369e0725627d881556"><td class="mdescLeft">&#160;</td><td class="mdescRight">See void awake(void* message=0).  <br /></td></tr>
<tr class="separator:ga22a404bcaf6641369e0725627d881556"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae9e8f440ce2ca05b047c620f75af13cb" id="r_gae9e8f440ce2ca05b047c620f75af13cb"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__multithread.html#gae9e8f440ce2ca05b047c620f75af13cb">awake</a> (void *message=0)</td></tr>
<tr class="memdesc:gae9e8f440ce2ca05b047c620f75af13cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends a message pointer to the main thread, causing any pending <a class="el" href="classFl.html#a108a84216f0b3fa1cb0c46ab7449a312" title="Waits until &quot;something happens&quot; and then returns.">Fl::wait()</a> call to terminate so that the main thread can retrieve the message and any pending redraws can be processed.  <br /></td></tr>
<tr class="separator:gae9e8f440ce2ca05b047c620f75af13cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a422da0dfc6aa51721e7c9a6ccf5b90ef" id="r_a422da0dfc6aa51721e7c9a6ccf5b90ef"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl.html#a422da0dfc6aa51721e7c9a6ccf5b90ef">background</a> (<a class="el" href="fl__types_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a>, <a class="el" href="fl__types_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a>, <a class="el" href="fl__types_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a>)</td></tr>
<tr class="memdesc:a422da0dfc6aa51721e7c9a6ccf5b90ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Changes fl_color(FL_BACKGROUND_COLOR) to the given color, and changes the gray ramp from 32 to 56 to black to white.  <br /></td></tr>
<tr class="separator:a422da0dfc6aa51721e7c9a6ccf5b90ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98d4c4557a2127bfc46abe15feed3be2" id="r_a98d4c4557a2127bfc46abe15feed3be2"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl.html#a98d4c4557a2127bfc46abe15feed3be2">background2</a> (<a class="el" href="fl__types_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a>, <a class="el" href="fl__types_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a>, <a class="el" href="fl__types_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a>)</td></tr>
<tr class="memdesc:a98d4c4557a2127bfc46abe15feed3be2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Changes the alternative background color.  <br /></td></tr>
<tr class="separator:a98d4c4557a2127bfc46abe15feed3be2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad00d4c6b0d9474ff6423cd47dd21e4c8" id="r_gad00d4c6b0d9474ff6423cd47dd21e4c8"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classFl__Widget.html">Fl_Widget</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__events.html#gad00d4c6b0d9474ff6423cd47dd21e4c8">belowmouse</a> ()</td></tr>
<tr class="memdesc:gad00d4c6b0d9474ff6423cd47dd21e4c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the widget that is below the mouse.  <br /></td></tr>
<tr class="separator:gad00d4c6b0d9474ff6423cd47dd21e4c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5a5c497679a904863019edf5375293bf" id="r_ga5a5c497679a904863019edf5375293bf"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__events.html#ga5a5c497679a904863019edf5375293bf">belowmouse</a> (<a class="el" href="classFl__Widget.html">Fl_Widget</a> *)</td></tr>
<tr class="memdesc:ga5a5c497679a904863019edf5375293bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the widget that is below the mouse.  <br /></td></tr>
<tr class="separator:ga5a5c497679a904863019edf5375293bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaaecb51f270a5b42ad31f0e8091635dd" id="r_aaaecb51f270a5b42ad31f0e8091635dd"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="Enumerations_8H.html#a8b762953646f8abee866061f1af78a6a">Fl_Color</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl.html#aaaecb51f270a5b42ad31f0e8091635dd">box_color</a> (<a class="el" href="Enumerations_8H.html#a8b762953646f8abee866061f1af78a6a">Fl_Color</a>)</td></tr>
<tr class="memdesc:aaaecb51f270a5b42ad31f0e8091635dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the drawing color to be used for the background of a box.  <br /></td></tr>
<tr class="separator:aaaecb51f270a5b42ad31f0e8091635dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af739a06d44dc94d09015ed1940b9f066" id="r_af739a06d44dc94d09015ed1940b9f066"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl.html#af739a06d44dc94d09015ed1940b9f066">box_dh</a> (<a class="el" href="Enumerations_8H.html#ae48bf9070f8541de17829f54ccacc6bc">Fl_Boxtype</a>)</td></tr>
<tr class="memdesc:af739a06d44dc94d09015ed1940b9f066"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the height offset for the given boxtype.  <br /></td></tr>
<tr class="separator:af739a06d44dc94d09015ed1940b9f066"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a327ed95a8c2533ca4eee659bf3d557" id="r_a9a327ed95a8c2533ca4eee659bf3d557"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl.html#a9a327ed95a8c2533ca4eee659bf3d557">box_dw</a> (<a class="el" href="Enumerations_8H.html#ae48bf9070f8541de17829f54ccacc6bc">Fl_Boxtype</a>)</td></tr>
<tr class="memdesc:a9a327ed95a8c2533ca4eee659bf3d557"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the width offset for the given boxtype.  <br /></td></tr>
<tr class="separator:a9a327ed95a8c2533ca4eee659bf3d557"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2971f20fe3595fd8f77fe73d4eb89594" id="r_a2971f20fe3595fd8f77fe73d4eb89594"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl.html#a2971f20fe3595fd8f77fe73d4eb89594">box_dx</a> (<a class="el" href="Enumerations_8H.html#ae48bf9070f8541de17829f54ccacc6bc">Fl_Boxtype</a>)</td></tr>
<tr class="memdesc:a2971f20fe3595fd8f77fe73d4eb89594"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the X offset for the given boxtype.  <br /></td></tr>
<tr class="separator:a2971f20fe3595fd8f77fe73d4eb89594"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fbd0a2a5c43a30893dec05e8d34dc15" id="r_a9fbd0a2a5c43a30893dec05e8d34dc15"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl.html#a9fbd0a2a5c43a30893dec05e8d34dc15">box_dy</a> (<a class="el" href="Enumerations_8H.html#ae48bf9070f8541de17829f54ccacc6bc">Fl_Boxtype</a>)</td></tr>
<tr class="memdesc:a9fbd0a2a5c43a30893dec05e8d34dc15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the Y offset for the given boxtype.  <br /></td></tr>
<tr class="separator:a9fbd0a2a5c43a30893dec05e8d34dc15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9a52d25377797666e43a46b520c485ac" id="r_ga9a52d25377797666e43a46b520c485ac"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__cairo.html#ga9a52d25377797666e43a46b520c485ac">cairo_autolink_context</a> ()</td></tr>
<tr class="memdesc:ga9a52d25377797666e43a46b520c485ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the current autolink mode for cairo support.  <br /></td></tr>
<tr class="separator:ga9a52d25377797666e43a46b520c485ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae5a1f7fcf75353908cc96b0edb928dd9" id="r_gae5a1f7fcf75353908cc96b0edb928dd9"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__cairo.html#gae5a1f7fcf75353908cc96b0edb928dd9">cairo_autolink_context</a> (bool alink)</td></tr>
<tr class="memdesc:gae5a1f7fcf75353908cc96b0edb928dd9"><td class="mdescLeft">&#160;</td><td class="mdescRight">when FLTK_HAVE_CAIRO is defined and <a class="el" href="group__group__cairo.html#ga9a52d25377797666e43a46b520c485ac" title="Gets the current autolink mode for cairo support.">cairo_autolink_context()</a> is true, any current window dc is linked to a current cairo context.  <br /></td></tr>
<tr class="separator:gae5a1f7fcf75353908cc96b0edb928dd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga174856102b465343b8cbceb42e59d630" id="r_ga174856102b465343b8cbceb42e59d630"><td class="memItemLeft" align="right" valign="top">
static cairo_t *&#160;</td><td class="memItemRight" valign="bottom"><b>cairo_cc</b> ()</td></tr>
<tr class="memdesc:ga174856102b465343b8cbceb42e59d630"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the current cairo context linked with a fltk window. <br /></td></tr>
<tr class="separator:ga174856102b465343b8cbceb42e59d630"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2bd5ba3321a80408a1460e114e2e5f99" id="r_ga2bd5ba3321a80408a1460e114e2e5f99"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__cairo.html#ga2bd5ba3321a80408a1460e114e2e5f99">cairo_cc</a> (cairo_t *c, bool own=false)</td></tr>
<tr class="memdesc:ga2bd5ba3321a80408a1460e114e2e5f99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the current cairo context to <code>c</code>.  <br /></td></tr>
<tr class="separator:ga2bd5ba3321a80408a1460e114e2e5f99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabc793671da89c45c42c32ff7a777b5e8" id="r_gabc793671da89c45c42c32ff7a777b5e8"><td class="memItemLeft" align="right" valign="top">static cairo_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__cairo.html#gabc793671da89c45c42c32ff7a777b5e8">cairo_make_current</a> (<a class="el" href="classFl__Window.html">Fl_Window</a> *<a class="el" href="group__fl__screen.html#ga4fcd39428db4299026322c91715cf379">w</a>)</td></tr>
<tr class="memdesc:gabc793671da89c45c42c32ff7a777b5e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides a corresponding cairo context for window <em>wi</em>.  <br /></td></tr>
<tr class="separator:gabc793671da89c45c42c32ff7a777b5e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1dbb83f1d52001c152ccf8415e3ee6f0" id="r_a1dbb83f1d52001c152ccf8415e3ee6f0"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl.html#a1dbb83f1d52001c152ccf8415e3ee6f0">check</a> ()</td></tr>
<tr class="memdesc:a1dbb83f1d52001c152ccf8415e3ee6f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as Fl::wait(0).  <br /></td></tr>
<tr class="separator:a1dbb83f1d52001c152ccf8415e3ee6f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad3cbd31083b47836cbe00ffb7006a4d4" id="r_gad3cbd31083b47836cbe00ffb7006a4d4"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__del__widget.html#gad3cbd31083b47836cbe00ffb7006a4d4">clear_widget_pointer</a> (<a class="el" href="classFl__Widget.html">Fl_Widget</a> const *<a class="el" href="group__fl__screen.html#ga4fcd39428db4299026322c91715cf379">w</a>)</td></tr>
<tr class="memdesc:gad3cbd31083b47836cbe00ffb7006a4d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears a widget pointer <em>in</em> the watch list.  <br /></td></tr>
<tr class="separator:gad3cbd31083b47836cbe00ffb7006a4d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae3e2af75e25fd4aa06aa41744cc4e493" id="r_gae3e2af75e25fd4aa06aa41744cc4e493"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__clipboard.html#gae3e2af75e25fd4aa06aa41744cc4e493">clipboard_contains</a> (const char *type)</td></tr>
<tr class="memdesc:gae3e2af75e25fd4aa06aa41744cc4e493"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns non 0 if the clipboard contains data matching <code>type</code>.  <br /></td></tr>
<tr class="separator:gae3e2af75e25fd4aa06aa41744cc4e493"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga79b619b0bccac6da8cdc55e6bb8a8d52" id="r_ga79b619b0bccac6da8cdc55e6bb8a8d52"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__events.html#ga79b619b0bccac6da8cdc55e6bb8a8d52">compose</a> (int &amp;del)</td></tr>
<tr class="memdesc:ga79b619b0bccac6da8cdc55e6bb8a8d52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Any text editing widget should call this for each FL_KEYBOARD event.  <br /></td></tr>
<tr class="separator:ga79b619b0bccac6da8cdc55e6bb8a8d52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaee29b04437dacb960cace49e84d62606" id="r_gaee29b04437dacb960cace49e84d62606"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__events.html#gaee29b04437dacb960cace49e84d62606">compose_reset</a> ()</td></tr>
<tr class="memdesc:gaee29b04437dacb960cace49e84d62606"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the user moves the cursor, be sure to call <a class="el" href="group__fl__events.html#gaee29b04437dacb960cace49e84d62606" title="If the user moves the cursor, be sure to call Fl::compose_reset().">Fl::compose_reset()</a>.  <br /></td></tr>
<tr class="separator:gaee29b04437dacb960cace49e84d62606"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga221bc2fa9bd737a8259a94a06f8005f0" id="r_ga221bc2fa9bd737a8259a94a06f8005f0"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__clipboard.html#ga221bc2fa9bd737a8259a94a06f8005f0">copy</a> (const char *stuff, int len, int destination=0, const char *type=<a class="el" href="group__fl__clipboard.html#ga96135e2dd04bfd737085ef5fb3d824e1">Fl::clipboard_plain_text</a>)</td></tr>
<tr class="memdesc:ga221bc2fa9bd737a8259a94a06f8005f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the data pointed to by <code>stuff</code> to the selection buffer (<code>destination</code> is 0), the clipboard (<code>destination</code> is 1), or both (<code>destination</code> is 2).  <br /></td></tr>
<tr class="separator:ga221bc2fa9bd737a8259a94a06f8005f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5e4de1119ebb169c8a8de4c81a4cb59" id="r_ac5e4de1119ebb169c8a8de4c81a4cb59"><td class="memItemLeft" align="right" valign="top"><a id="ac5e4de1119ebb169c8a8de4c81a4cb59" name="ac5e4de1119ebb169c8a8de4c81a4cb59"></a>
static int&#160;</td><td class="memItemRight" valign="bottom"><b>damage</b> ()</td></tr>
<tr class="memdesc:ac5e4de1119ebb169c8a8de4c81a4cb59"><td class="mdescLeft">&#160;</td><td class="mdescRight">If true then <a class="el" href="classFl.html#a08d29d807ea3874b8bb16f7457f64bdc" title="Causes all the windows that need it to be redrawn and graphics forced out through the pipes.">flush()</a> will do something. <br /></td></tr>
<tr class="separator:ac5e4de1119ebb169c8a8de4c81a4cb59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45391ff5a25464a6e40658b58bf3ef98" id="r_a45391ff5a25464a6e40658b58bf3ef98"><td class="memItemLeft" align="right" valign="top"><a id="a45391ff5a25464a6e40658b58bf3ef98" name="a45391ff5a25464a6e40658b58bf3ef98"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><b>damage</b> (int d)</td></tr>
<tr class="memdesc:a45391ff5a25464a6e40658b58bf3ef98"><td class="mdescLeft">&#160;</td><td class="mdescRight">If true then <a class="el" href="classFl.html#a08d29d807ea3874b8bb16f7457f64bdc" title="Causes all the windows that need it to be redrawn and graphics forced out through the pipes.">flush()</a> will do something. <br /></td></tr>
<tr class="separator:a45391ff5a25464a6e40658b58bf3ef98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadd064730c5ea01306754bc5c35df24f9" id="r_gadd064730c5ea01306754bc5c35df24f9"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__windows.html#gadd064730c5ea01306754bc5c35df24f9">default_atclose</a> (<a class="el" href="classFl__Window.html">Fl_Window</a> *, void *)</td></tr>
<tr class="memdesc:gadd064730c5ea01306754bc5c35df24f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default callback for window widgets.  <br /></td></tr>
<tr class="separator:gadd064730c5ea01306754bc5c35df24f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga609413ac47ba433d1e7da8678a27164f" id="r_ga609413ac47ba433d1e7da8678a27164f"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__del__widget.html#ga609413ac47ba433d1e7da8678a27164f">delete_widget</a> (<a class="el" href="classFl__Widget.html">Fl_Widget</a> *<a class="el" href="group__fl__screen.html#ga4fcd39428db4299026322c91715cf379">w</a>)</td></tr>
<tr class="memdesc:ga609413ac47ba433d1e7da8678a27164f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Schedules a widget for deletion at the next call to the event loop.  <br /></td></tr>
<tr class="separator:ga609413ac47ba433d1e7da8678a27164f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga792ec093c9ef58930ac0657152bee665" id="r_ga792ec093c9ef58930ac0657152bee665"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__events.html#ga792ec093c9ef58930ac0657152bee665">disable_im</a> ()</td></tr>
<tr class="memdesc:ga792ec093c9ef58930ac0657152bee665"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disables the system input methods facilities.  <br /></td></tr>
<tr class="separator:ga792ec093c9ef58930ac0657152bee665"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c6847e1b7dd9628821656933ca8e79d" id="r_a7c6847e1b7dd9628821656933ca8e79d"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl.html#a7c6847e1b7dd9628821656933ca8e79d">display</a> (const char *)</td></tr>
<tr class="memdesc:a7c6847e1b7dd9628821656933ca8e79d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the X display to use for all windows.  <br /></td></tr>
<tr class="separator:a7c6847e1b7dd9628821656933ca8e79d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga42026e276b8e83312ce58b264d1d4dcc" id="r_ga42026e276b8e83312ce58b264d1d4dcc"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__clipboard.html#ga42026e276b8e83312ce58b264d1d4dcc">dnd</a> ()</td></tr>
<tr class="memdesc:ga42026e276b8e83312ce58b264d1d4dcc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initiate a Drag And Drop operation.  <br /></td></tr>
<tr class="separator:ga42026e276b8e83312ce58b264d1d4dcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae157def51e4dabe5f75298b676ddea2" id="r_aae157def51e4dabe5f75298b676ddea2"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl.html#aae157def51e4dabe5f75298b676ddea2">dnd_text_ops</a> ()</td></tr>
<tr class="memdesc:aae157def51e4dabe5f75298b676ddea2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets or sets whether drag and drop text operations are supported.  <br /></td></tr>
<tr class="separator:aae157def51e4dabe5f75298b676ddea2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53430e25b53f3b608193fa4009898463" id="r_a53430e25b53f3b608193fa4009898463"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl.html#a53430e25b53f3b608193fa4009898463">dnd_text_ops</a> (int v)</td></tr>
<tr class="memdesc:a53430e25b53f3b608193fa4009898463"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets or sets whether drag and drop text operations are supported.  <br /></td></tr>
<tr class="separator:a53430e25b53f3b608193fa4009898463"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga838010444986ae57301d6e8289d2dfbb" id="r_ga838010444986ae57301d6e8289d2dfbb"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__del__widget.html#ga838010444986ae57301d6e8289d2dfbb">do_widget_deletion</a> ()</td></tr>
<tr class="memdesc:ga838010444986ae57301d6e8289d2dfbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes widgets previously scheduled for deletion.  <br /></td></tr>
<tr class="separator:ga838010444986ae57301d6e8289d2dfbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad56cf568ee94318b50d2b2da0aa3031b" id="r_ad56cf568ee94318b50d2b2da0aa3031b"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl.html#ad56cf568ee94318b50d2b2da0aa3031b">draw_box_active</a> ()</td></tr>
<tr class="memdesc:ad56cf568ee94318b50d2b2da0aa3031b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if the currently drawn box is active or inactive.  <br /></td></tr>
<tr class="separator:ad56cf568ee94318b50d2b2da0aa3031b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9552df530b2efea9a81fa04d872d3f2a" id="r_ga9552df530b2efea9a81fa04d872d3f2a"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__events.html#ga9552df530b2efea9a81fa04d872d3f2a">enable_im</a> ()</td></tr>
<tr class="memdesc:ga9552df530b2efea9a81fa04d872d3f2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables the system input methods facilities.  <br /></td></tr>
<tr class="separator:ga9552df530b2efea9a81fa04d872d3f2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac7595e274aaebaa23982125a1363d13f" id="r_gac7595e274aaebaa23982125a1363d13f"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__events.html#gac7595e274aaebaa23982125a1363d13f">event</a> ()</td></tr>
<tr class="memdesc:gac7595e274aaebaa23982125a1363d13f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the last event that was processed.  <br /></td></tr>
<tr class="separator:gac7595e274aaebaa23982125a1363d13f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1ee32cc3de557d5a1cc81a1eab944929" id="r_ga1ee32cc3de557d5a1cc81a1eab944929"><td class="memItemLeft" align="right" valign="top">
static int&#160;</td><td class="memItemRight" valign="bottom"><b>event_alt</b> ()</td></tr>
<tr class="memdesc:ga1ee32cc3de557d5a1cc81a1eab944929"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns non-zero if the Alt key is pressed. <br /></td></tr>
<tr class="separator:ga1ee32cc3de557d5a1cc81a1eab944929"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7ae6d99ceb1a2afb8a1dc4455ac941cd" id="r_ga7ae6d99ceb1a2afb8a1dc4455ac941cd"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__events.html#ga7ae6d99ceb1a2afb8a1dc4455ac941cd">event_button</a> ()</td></tr>
<tr class="memdesc:ga7ae6d99ceb1a2afb8a1dc4455ac941cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets which particular mouse button caused the current event.  <br /></td></tr>
<tr class="separator:ga7ae6d99ceb1a2afb8a1dc4455ac941cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6ec5fa15a7ea5229cbff8dd507130d46" id="r_ga6ec5fa15a7ea5229cbff8dd507130d46"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__events.html#ga6ec5fa15a7ea5229cbff8dd507130d46">event_button1</a> ()</td></tr>
<tr class="memdesc:ga6ec5fa15a7ea5229cbff8dd507130d46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns non-zero if mouse button 1 is currently held down.  <br /></td></tr>
<tr class="separator:ga6ec5fa15a7ea5229cbff8dd507130d46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad85ae7c11308de6e4653a860729dec77" id="r_gad85ae7c11308de6e4653a860729dec77"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__events.html#gad85ae7c11308de6e4653a860729dec77">event_button2</a> ()</td></tr>
<tr class="memdesc:gad85ae7c11308de6e4653a860729dec77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns non-zero if button 2 is currently held down.  <br /></td></tr>
<tr class="separator:gad85ae7c11308de6e4653a860729dec77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga70f54fbed74f801495575939dc787361" id="r_ga70f54fbed74f801495575939dc787361"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__events.html#ga70f54fbed74f801495575939dc787361">event_button3</a> ()</td></tr>
<tr class="memdesc:ga70f54fbed74f801495575939dc787361"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns non-zero if button 3 is currently held down.  <br /></td></tr>
<tr class="separator:ga70f54fbed74f801495575939dc787361"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaee06c25589974fafb1c8df8d0e2c7c80" id="r_gaee06c25589974fafb1c8df8d0e2c7c80"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__events.html#gaee06c25589974fafb1c8df8d0e2c7c80">event_buttons</a> ()</td></tr>
<tr class="memdesc:gaee06c25589974fafb1c8df8d0e2c7c80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the mouse buttons state bits; if non-zero, then at least one button is pressed now.  <br /></td></tr>
<tr class="separator:gaee06c25589974fafb1c8df8d0e2c7c80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafa31b53b34bd43ee107806a3bbc640d1" id="r_gafa31b53b34bd43ee107806a3bbc640d1"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__events.html#gafa31b53b34bd43ee107806a3bbc640d1">event_clicks</a> ()</td></tr>
<tr class="memdesc:gafa31b53b34bd43ee107806a3bbc640d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns non zero if we had a double click event.  <br /></td></tr>
<tr class="separator:gafa31b53b34bd43ee107806a3bbc640d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0531622eb47fab712faedd43eab886d9" id="r_ga0531622eb47fab712faedd43eab886d9"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__events.html#ga0531622eb47fab712faedd43eab886d9">event_clicks</a> (int i)</td></tr>
<tr class="memdesc:ga0531622eb47fab712faedd43eab886d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Manually sets the number returned by <a class="el" href="group__fl__events.html#gafa31b53b34bd43ee107806a3bbc640d1" title="Returns non zero if we had a double click event.">Fl::event_clicks()</a>.  <br /></td></tr>
<tr class="separator:ga0531622eb47fab712faedd43eab886d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaef12e20d3ecff95920ed3845da0bee8" id="r_gaaef12e20d3ecff95920ed3845da0bee8"><td class="memItemLeft" align="right" valign="top">static void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__events.html#gaaef12e20d3ecff95920ed3845da0bee8">event_clipboard</a> ()</td></tr>
<tr class="memdesc:gaaef12e20d3ecff95920ed3845da0bee8"><td class="mdescLeft">&#160;</td><td class="mdescRight">During an FL_PASTE event of non-textual data, returns a pointer to the pasted data.  <br /></td></tr>
<tr class="separator:gaaef12e20d3ecff95920ed3845da0bee8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga68c42139b1b2db10c38aa06a70a70a7f" id="r_ga68c42139b1b2db10c38aa06a70a70a7f"><td class="memItemLeft" align="right" valign="top">static const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__events.html#ga68c42139b1b2db10c38aa06a70a70a7f">event_clipboard_type</a> ()</td></tr>
<tr class="memdesc:ga68c42139b1b2db10c38aa06a70a70a7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the type of the pasted data during an FL_PASTE event.  <br /></td></tr>
<tr class="separator:ga68c42139b1b2db10c38aa06a70a70a7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga73da625a4d77f730da5e0bd0e8823be9" id="r_ga73da625a4d77f730da5e0bd0e8823be9"><td class="memItemLeft" align="right" valign="top">
static int&#160;</td><td class="memItemRight" valign="bottom"><b>event_command</b> ()</td></tr>
<tr class="memdesc:ga73da625a4d77f730da5e0bd0e8823be9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns non-zero if the FL_COMMAND key is pressed, either FL_CTRL or on OSX FL_META. <br /></td></tr>
<tr class="separator:ga73da625a4d77f730da5e0bd0e8823be9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gace54a534aad4a88dac170871a5bcbe1a" id="r_gace54a534aad4a88dac170871a5bcbe1a"><td class="memItemLeft" align="right" valign="top">
static int&#160;</td><td class="memItemRight" valign="bottom"><b>event_ctrl</b> ()</td></tr>
<tr class="memdesc:gace54a534aad4a88dac170871a5bcbe1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns non-zero if the Control key is pressed. <br /></td></tr>
<tr class="separator:gace54a534aad4a88dac170871a5bcbe1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafad45688b3e262a38151320a4059e04d" id="r_gafad45688b3e262a38151320a4059e04d"><td class="memItemLeft" align="right" valign="top">
static <a class="el" href="group__callback__functions.html#ga2fa80da592860bc4c0c1a06d36262601">Fl_Event_Dispatch</a>&#160;</td><td class="memItemRight" valign="bottom"><b>event_dispatch</b> ()</td></tr>
<tr class="memdesc:gafad45688b3e262a38151320a4059e04d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the current event dispatch function. <br /></td></tr>
<tr class="separator:gafad45688b3e262a38151320a4059e04d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafc8bd62d8fdacef87c56ed3a22cdcebc" id="r_gafc8bd62d8fdacef87c56ed3a22cdcebc"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__events.html#gafc8bd62d8fdacef87c56ed3a22cdcebc">event_dispatch</a> (<a class="el" href="group__callback__functions.html#ga2fa80da592860bc4c0c1a06d36262601">Fl_Event_Dispatch</a> d)</td></tr>
<tr class="memdesc:gafc8bd62d8fdacef87c56ed3a22cdcebc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a new event dispatch function.  <br /></td></tr>
<tr class="separator:gafc8bd62d8fdacef87c56ed3a22cdcebc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadd50231ad95aaf23a23e9db42cccb42e" id="r_gadd50231ad95aaf23a23e9db42cccb42e"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__events.html#gadd50231ad95aaf23a23e9db42cccb42e">event_dx</a> ()</td></tr>
<tr class="memdesc:gadd50231ad95aaf23a23e9db42cccb42e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current horizontal mouse scrolling associated with the FL_MOUSEWHEEL event.  <br /></td></tr>
<tr class="separator:gadd50231ad95aaf23a23e9db42cccb42e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4704bd4e93b6471321d6ac84b0df97e5" id="r_ga4704bd4e93b6471321d6ac84b0df97e5"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__events.html#ga4704bd4e93b6471321d6ac84b0df97e5">event_dy</a> ()</td></tr>
<tr class="memdesc:ga4704bd4e93b6471321d6ac84b0df97e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current vertical mouse scrolling associated with the FL_MOUSEWHEEL event.  <br /></td></tr>
<tr class="separator:ga4704bd4e93b6471321d6ac84b0df97e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga143c28ca9e41cb919be1c4c72227a475" id="r_ga143c28ca9e41cb919be1c4c72227a475"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__events.html#ga143c28ca9e41cb919be1c4c72227a475">event_inside</a> (const <a class="el" href="classFl__Widget.html">Fl_Widget</a> *)</td></tr>
<tr class="memdesc:ga143c28ca9e41cb919be1c4c72227a475"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether or not the mouse event is inside a given child widget.  <br /></td></tr>
<tr class="separator:ga143c28ca9e41cb919be1c4c72227a475"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga277f38696ffa53b63325b13ac51976bb" id="r_ga277f38696ffa53b63325b13ac51976bb"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__events.html#ga277f38696ffa53b63325b13ac51976bb">event_inside</a> (int, int, int, int)</td></tr>
<tr class="memdesc:ga277f38696ffa53b63325b13ac51976bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether or not the mouse event is inside the given rectangle.  <br /></td></tr>
<tr class="separator:ga277f38696ffa53b63325b13ac51976bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae4f3bafeb9fbae98c3b7cc6f5326e582" id="r_gae4f3bafeb9fbae98c3b7cc6f5326e582"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__events.html#gae4f3bafeb9fbae98c3b7cc6f5326e582">event_is_click</a> ()</td></tr>
<tr class="memdesc:gae4f3bafeb9fbae98c3b7cc6f5326e582"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns non-zero if the mouse has not moved far enough and not enough time has passed since the last FL_PUSH or FL_KEYBOARD event for it to be considered a "drag" rather than a "click".  <br /></td></tr>
<tr class="separator:gae4f3bafeb9fbae98c3b7cc6f5326e582"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga08ba811a19462788094768ed98798120" id="r_ga08ba811a19462788094768ed98798120"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__events.html#ga08ba811a19462788094768ed98798120">event_is_click</a> (int i)</td></tr>
<tr class="memdesc:ga08ba811a19462788094768ed98798120"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the value returned by <a class="el" href="group__fl__events.html#gae4f3bafeb9fbae98c3b7cc6f5326e582" title="Returns non-zero if the mouse has not moved far enough and not enough time has passed since the last ...">Fl::event_is_click()</a>.  <br /></td></tr>
<tr class="separator:ga08ba811a19462788094768ed98798120"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1ac131e3cd5ca674cc022b1f77233449" id="r_ga1ac131e3cd5ca674cc022b1f77233449"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__events.html#ga1ac131e3cd5ca674cc022b1f77233449">event_key</a> ()</td></tr>
<tr class="memdesc:ga1ac131e3cd5ca674cc022b1f77233449"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets which key on the keyboard was last pushed.  <br /></td></tr>
<tr class="separator:ga1ac131e3cd5ca674cc022b1f77233449"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga12be48f03872da009734f557d1e761bc" id="r_ga12be48f03872da009734f557d1e761bc"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__events.html#ga12be48f03872da009734f557d1e761bc">event_key</a> (int key)</td></tr>
<tr class="memdesc:ga12be48f03872da009734f557d1e761bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the given <code>key</code> was held down (or pressed) <em>during</em> the last event.  <br /></td></tr>
<tr class="separator:ga12be48f03872da009734f557d1e761bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga38f2de89fbdf59ad2cd4dca93f472911" id="r_ga38f2de89fbdf59ad2cd4dca93f472911"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__events.html#ga38f2de89fbdf59ad2cd4dca93f472911">event_length</a> ()</td></tr>
<tr class="memdesc:ga38f2de89fbdf59ad2cd4dca93f472911"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the length of the text in <a class="el" href="group__fl__events.html#gae5cf69191d2381f0333dbc83bdd32f75" title="Returns the text associated with the current event, including FL_PASTE or FL_DND_RELEASE events.">Fl::event_text()</a>.  <br /></td></tr>
<tr class="separator:ga38f2de89fbdf59ad2cd4dca93f472911"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadec41d640b647e422b88331015ab660d" id="r_gadec41d640b647e422b88331015ab660d"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__events.html#gadec41d640b647e422b88331015ab660d">event_original_key</a> ()</td></tr>
<tr class="memdesc:gadec41d640b647e422b88331015ab660d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the keycode of the last key event, regardless of the NumLock state.  <br /></td></tr>
<tr class="separator:gadec41d640b647e422b88331015ab660d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabd68dc8a592e9a2a41b42cb7e3a30060" id="r_gabd68dc8a592e9a2a41b42cb7e3a30060"><td class="memItemLeft" align="right" valign="top">
static int&#160;</td><td class="memItemRight" valign="bottom"><b>event_shift</b> ()</td></tr>
<tr class="memdesc:gabd68dc8a592e9a2a41b42cb7e3a30060"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns non-zero if the Shift key is pressed. <br /></td></tr>
<tr class="separator:gabd68dc8a592e9a2a41b42cb7e3a30060"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafa17a5b4d8d9163631c88142e60447ed" id="r_gafa17a5b4d8d9163631c88142e60447ed"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__events.html#gafa17a5b4d8d9163631c88142e60447ed">event_state</a> ()</td></tr>
<tr class="memdesc:gafa17a5b4d8d9163631c88142e60447ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the keyboard and mouse button states of the last event.  <br /></td></tr>
<tr class="separator:gafa17a5b4d8d9163631c88142e60447ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3a32c24a501002db29b66008a175a558" id="r_ga3a32c24a501002db29b66008a175a558"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__events.html#ga3a32c24a501002db29b66008a175a558">event_state</a> (int mask)</td></tr>
<tr class="memdesc:ga3a32c24a501002db29b66008a175a558"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns non-zero if any of the passed event state bits are turned on.  <br /></td></tr>
<tr class="separator:ga3a32c24a501002db29b66008a175a558"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae5cf69191d2381f0333dbc83bdd32f75" id="r_gae5cf69191d2381f0333dbc83bdd32f75"><td class="memItemLeft" align="right" valign="top">static const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__events.html#gae5cf69191d2381f0333dbc83bdd32f75">event_text</a> ()</td></tr>
<tr class="memdesc:gae5cf69191d2381f0333dbc83bdd32f75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the text associated with the current event, including FL_PASTE or FL_DND_RELEASE events.  <br /></td></tr>
<tr class="separator:gae5cf69191d2381f0333dbc83bdd32f75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga91585fcbaa1e79f7452fd2d16a82136e" id="r_ga91585fcbaa1e79f7452fd2d16a82136e"><td class="memItemLeft" align="right" valign="top">
static int&#160;</td><td class="memItemRight" valign="bottom"><b>event_x</b> ()</td></tr>
<tr class="memdesc:ga91585fcbaa1e79f7452fd2d16a82136e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the mouse position of the event relative to the <a class="el" href="classFl__Window.html" title="This widget produces an actual window.">Fl_Window</a> it was passed to. <br /></td></tr>
<tr class="separator:ga91585fcbaa1e79f7452fd2d16a82136e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4c40bd0d2960354c9778fdb65a2b720d" id="r_ga4c40bd0d2960354c9778fdb65a2b720d"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__events.html#ga4c40bd0d2960354c9778fdb65a2b720d">event_x_root</a> ()</td></tr>
<tr class="memdesc:ga4c40bd0d2960354c9778fdb65a2b720d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the mouse position on the screen of the event.  <br /></td></tr>
<tr class="separator:ga4c40bd0d2960354c9778fdb65a2b720d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga192a0c5a37f33b9d117a69f20977c2a1" id="r_ga192a0c5a37f33b9d117a69f20977c2a1"><td class="memItemLeft" align="right" valign="top">
static int&#160;</td><td class="memItemRight" valign="bottom"><b>event_y</b> ()</td></tr>
<tr class="memdesc:ga192a0c5a37f33b9d117a69f20977c2a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the mouse position of the event relative to the <a class="el" href="classFl__Window.html" title="This widget produces an actual window.">Fl_Window</a> it was passed to. <br /></td></tr>
<tr class="separator:ga192a0c5a37f33b9d117a69f20977c2a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9801003f911eae0e49bf52b875dcaaa5" id="r_ga9801003f911eae0e49bf52b875dcaaa5"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__events.html#ga9801003f911eae0e49bf52b875dcaaa5">event_y_root</a> ()</td></tr>
<tr class="memdesc:ga9801003f911eae0e49bf52b875dcaaa5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the mouse position on the screen of the event.  <br /></td></tr>
<tr class="separator:ga9801003f911eae0e49bf52b875dcaaa5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3130407bc1c11f9b7f2a9c43a87a1599" id="r_ga3130407bc1c11f9b7f2a9c43a87a1599"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classFl__Window.html">Fl_Window</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__windows.html#ga3130407bc1c11f9b7f2a9c43a87a1599">first_window</a> ()</td></tr>
<tr class="memdesc:ga3130407bc1c11f9b7f2a9c43a87a1599"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the first top-level window in the list of shown() windows.  <br /></td></tr>
<tr class="separator:ga3130407bc1c11f9b7f2a9c43a87a1599"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabac1e48dd4e0fa7431776c1e754e273e" id="r_gabac1e48dd4e0fa7431776c1e754e273e"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__windows.html#gabac1e48dd4e0fa7431776c1e754e273e">first_window</a> (<a class="el" href="classFl__Window.html">Fl_Window</a> *)</td></tr>
<tr class="memdesc:gabac1e48dd4e0fa7431776c1e754e273e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the window that is returned by <a class="el" href="group__fl__windows.html#ga3130407bc1c11f9b7f2a9c43a87a1599" title="Returns the first top-level window in the list of shown() windows.">first_window()</a>.  <br /></td></tr>
<tr class="separator:gabac1e48dd4e0fa7431776c1e754e273e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08d29d807ea3874b8bb16f7457f64bdc" id="r_a08d29d807ea3874b8bb16f7457f64bdc"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl.html#a08d29d807ea3874b8bb16f7457f64bdc">flush</a> ()</td></tr>
<tr class="memdesc:a08d29d807ea3874b8bb16f7457f64bdc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Causes all the windows that need it to be redrawn and graphics forced out through the pipes.  <br /></td></tr>
<tr class="separator:a08d29d807ea3874b8bb16f7457f64bdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga38b004e3a0aaf3d122b1676817a9cc30" id="r_ga38b004e3a0aaf3d122b1676817a9cc30"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classFl__Widget.html">Fl_Widget</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__events.html#ga38b004e3a0aaf3d122b1676817a9cc30">focus</a> ()</td></tr>
<tr class="memdesc:ga38b004e3a0aaf3d122b1676817a9cc30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the current <a class="el" href="group__fl__events.html#ga38b004e3a0aaf3d122b1676817a9cc30" title="Gets the current Fl::focus() widget.">Fl::focus()</a> widget.  <br /></td></tr>
<tr class="separator:ga38b004e3a0aaf3d122b1676817a9cc30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1f6eb61b05d03838978c6a1a8016ce7a" id="r_ga1f6eb61b05d03838978c6a1a8016ce7a"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__events.html#ga1f6eb61b05d03838978c6a1a8016ce7a">focus</a> (<a class="el" href="classFl__Widget.html">Fl_Widget</a> *)</td></tr>
<tr class="memdesc:ga1f6eb61b05d03838978c6a1a8016ce7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the widget that will receive FL_KEYBOARD events.  <br /></td></tr>
<tr class="separator:ga1f6eb61b05d03838978c6a1a8016ce7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbf02f998cce7ebb3331def57fccc8a7" id="r_afbf02f998cce7ebb3331def57fccc8a7"><td class="memItemLeft" align="right" valign="top"><a id="afbf02f998cce7ebb3331def57fccc8a7" name="afbf02f998cce7ebb3331def57fccc8a7"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><b>foreground</b> (<a class="el" href="fl__types_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a>, <a class="el" href="fl__types_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a>, <a class="el" href="fl__types_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a>)</td></tr>
<tr class="memdesc:afbf02f998cce7ebb3331def57fccc8a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Changes fl_color(FL_FOREGROUND_COLOR). <br /></td></tr>
<tr class="separator:afbf02f998cce7ebb3331def57fccc8a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae68ad6c3474fb71b3db5a44658b60b14" id="r_gae68ad6c3474fb71b3db5a44658b60b14"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__attributes.html#gae68ad6c3474fb71b3db5a44658b60b14">free_color</a> (<a class="el" href="Enumerations_8H.html#a8b762953646f8abee866061f1af78a6a">Fl_Color</a> i, int overlay=0)</td></tr>
<tr class="memdesc:gae68ad6c3474fb71b3db5a44658b60b14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees the specified color from the colormap, if applicable.  <br /></td></tr>
<tr class="separator:gae68ad6c3474fb71b3db5a44658b60b14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a837ed3f58be4ad9ed3949e31678bc8fe" id="r_a837ed3f58be4ad9ed3949e31678bc8fe"><td class="memItemLeft" align="right" valign="top"><a id="a837ed3f58be4ad9ed3949e31678bc8fe" name="a837ed3f58be4ad9ed3949e31678bc8fe"></a>
static int&#160;</td><td class="memItemRight" valign="bottom"><b>get_awake_handler_</b> (<a class="el" href="group__callback__functions.html#ga28b44ff2052ca0b06d0da852fadd42c0">Fl_Awake_Handler</a> &amp;, void *&amp;)</td></tr>
<tr class="memdesc:a837ed3f58be4ad9ed3949e31678bc8fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the last stored awake handler for use in <a class="el" href="group__fl__multithread.html#gae9e8f440ce2ca05b047c620f75af13cb" title="Sends a message pointer to the main thread, causing any pending Fl::wait() call to terminate so that ...">awake()</a>. <br /></td></tr>
<tr class="separator:a837ed3f58be4ad9ed3949e31678bc8fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62d53b0d7749d7c3d053e72ee2a5a816" id="r_a62d53b0d7749d7c3d053e72ee2a5a816"><td class="memItemLeft" align="right" valign="top"><a id="a62d53b0d7749d7c3d053e72ee2a5a816" name="a62d53b0d7749d7c3d053e72ee2a5a816"></a>
static <a class="el" href="group__callback__functions.html#gacb24a62f521a0e02cd7872a3bfbf3855">Fl_Box_Draw_F</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>get_boxtype</b> (<a class="el" href="Enumerations_8H.html#ae48bf9070f8541de17829f54ccacc6bc">Fl_Boxtype</a>)</td></tr>
<tr class="memdesc:a62d53b0d7749d7c3d053e72ee2a5a816"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the current box drawing function for the specified box type. <br /></td></tr>
<tr class="separator:a62d53b0d7749d7c3d053e72ee2a5a816"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9977c7ef50c9f51efd0d7909020a16da" id="r_ga9977c7ef50c9f51efd0d7909020a16da"><td class="memItemLeft" align="right" valign="top">static unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__attributes.html#ga9977c7ef50c9f51efd0d7909020a16da">get_color</a> (<a class="el" href="Enumerations_8H.html#a8b762953646f8abee866061f1af78a6a">Fl_Color</a> i)</td></tr>
<tr class="memdesc:ga9977c7ef50c9f51efd0d7909020a16da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the RGB value(s) for the given FLTK color index.  <br /></td></tr>
<tr class="separator:ga9977c7ef50c9f51efd0d7909020a16da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4eb8db6ea9968f546687f89a4ec336a0" id="r_ga4eb8db6ea9968f546687f89a4ec336a0"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__attributes.html#ga4eb8db6ea9968f546687f89a4ec336a0">get_color</a> (<a class="el" href="Enumerations_8H.html#a8b762953646f8abee866061f1af78a6a">Fl_Color</a> i, <a class="el" href="fl__types_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> &amp;red, <a class="el" href="fl__types_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> &amp;green, <a class="el" href="fl__types_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> &amp;blue)</td></tr>
<tr class="memdesc:ga4eb8db6ea9968f546687f89a4ec336a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the RGB value(s) for the given FLTK color index.  <br /></td></tr>
<tr class="separator:ga4eb8db6ea9968f546687f89a4ec336a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac822bdf31f387b4dfc520e8b261b6b1a" id="r_gac822bdf31f387b4dfc520e8b261b6b1a"><td class="memItemLeft" align="right" valign="top">static const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__attributes.html#gac822bdf31f387b4dfc520e8b261b6b1a">get_font</a> (<a class="el" href="Enumerations_8H.html#a2ac46d9f082834b969fffe490a03a709">Fl_Font</a>)</td></tr>
<tr class="memdesc:gac822bdf31f387b4dfc520e8b261b6b1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the string for this face.  <br /></td></tr>
<tr class="separator:gac822bdf31f387b4dfc520e8b261b6b1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga90b30b9bc92f6a263928d028de07fe23" id="r_ga90b30b9bc92f6a263928d028de07fe23"><td class="memItemLeft" align="right" valign="top">static const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__attributes.html#ga90b30b9bc92f6a263928d028de07fe23">get_font_name</a> (<a class="el" href="Enumerations_8H.html#a2ac46d9f082834b969fffe490a03a709">Fl_Font</a>, int *attributes=0)</td></tr>
<tr class="memdesc:ga90b30b9bc92f6a263928d028de07fe23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a human-readable string describing the family of this face.  <br /></td></tr>
<tr class="separator:ga90b30b9bc92f6a263928d028de07fe23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga435176ea0a7ed5b8e5eb65792cfbcb20" id="r_ga435176ea0a7ed5b8e5eb65792cfbcb20"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__attributes.html#ga435176ea0a7ed5b8e5eb65792cfbcb20">get_font_sizes</a> (<a class="el" href="Enumerations_8H.html#a2ac46d9f082834b969fffe490a03a709">Fl_Font</a>, int *&amp;sizep)</td></tr>
<tr class="memdesc:ga435176ea0a7ed5b8e5eb65792cfbcb20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an array of sizes in <code>sizep</code>.  <br /></td></tr>
<tr class="separator:ga435176ea0a7ed5b8e5eb65792cfbcb20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab7049319eed772c8a22cf2c0eb484a39" id="r_gab7049319eed772c8a22cf2c0eb484a39"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__events.html#gab7049319eed772c8a22cf2c0eb484a39">get_key</a> (int key)</td></tr>
<tr class="memdesc:gab7049319eed772c8a22cf2c0eb484a39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the given <code>key</code> is held down <em>now</em>.  <br /></td></tr>
<tr class="separator:gab7049319eed772c8a22cf2c0eb484a39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga79a94c0ac0f71557ef4b6dc7b8d863db" id="r_ga79a94c0ac0f71557ef4b6dc7b8d863db"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__events.html#ga79a94c0ac0f71557ef4b6dc7b8d863db">get_mouse</a> (int &amp;, int &amp;)</td></tr>
<tr class="memdesc:ga79a94c0ac0f71557ef4b6dc7b8d863db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return where the mouse is on the screen by doing a round-trip query to the server.  <br /></td></tr>
<tr class="separator:ga79a94c0ac0f71557ef4b6dc7b8d863db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed0a7958eebf1491685040be87490947" id="r_aed0a7958eebf1491685040be87490947"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl.html#aed0a7958eebf1491685040be87490947">get_system_colors</a> ()</td></tr>
<tr class="memdesc:aed0a7958eebf1491685040be87490947"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the user preference colors from the system and use them to call <a class="el" href="classFl.html#afbf02f998cce7ebb3331def57fccc8a7" title="Changes fl_color(FL_FOREGROUND_COLOR).">Fl::foreground()</a>, <a class="el" href="classFl.html#a422da0dfc6aa51721e7c9a6ccf5b90ef" title="Changes fl_color(FL_BACKGROUND_COLOR) to the given color, and changes the gray ramp from 32 to 56 to ...">Fl::background()</a>, and <a class="el" href="classFl.html#a98d4c4557a2127bfc46abe15feed3be2" title="Changes the alternative background color.">Fl::background2()</a>.  <br /></td></tr>
<tr class="separator:aed0a7958eebf1491685040be87490947"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d21e87ef889306a7be56e94ea0bda10" id="r_a3d21e87ef889306a7be56e94ea0bda10"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl.html#a3d21e87ef889306a7be56e94ea0bda10">gl_visual</a> (int, int *alist=0)</td></tr>
<tr class="memdesc:a3d21e87ef889306a7be56e94ea0bda10"><td class="mdescLeft">&#160;</td><td class="mdescRight">This does the same thing as <a class="el" href="classFl.html#a6d6deb3d4f76b538d508b36700dfb6b0" title="Selects a visual so that your graphics are drawn correctly.">Fl::visual(int)</a> but also requires OpenGL drawing to work.  <br /></td></tr>
<tr class="separator:a3d21e87ef889306a7be56e94ea0bda10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabe4356666946421cd56f3678889d92bd" id="r_gabe4356666946421cd56f3678889d92bd"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classFl__Window.html">Fl_Window</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__windows.html#gabe4356666946421cd56f3678889d92bd">grab</a> ()</td></tr>
<tr class="memdesc:gabe4356666946421cd56f3678889d92bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the window that currently receives all events.  <br /></td></tr>
<tr class="separator:gabe4356666946421cd56f3678889d92bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab59edda7c6a51ff2cb4673f21b739088" id="r_ab59edda7c6a51ff2cb4673f21b739088"><td class="memItemLeft" align="right" valign="top"><a id="ab59edda7c6a51ff2cb4673f21b739088" name="ab59edda7c6a51ff2cb4673f21b739088"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><b>grab</b> (<a class="el" href="classFl__Window.html">Fl_Window</a> &amp;win)</td></tr>
<tr class="memdesc:ab59edda7c6a51ff2cb4673f21b739088"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="group__fl__windows.html#ga0918f4dabb87b5e429ad4e0e38239845" title="Selects the window to grab.">grab(Fl_Window*)</a> <br /></td></tr>
<tr class="separator:ab59edda7c6a51ff2cb4673f21b739088"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0918f4dabb87b5e429ad4e0e38239845" id="r_ga0918f4dabb87b5e429ad4e0e38239845"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__windows.html#ga0918f4dabb87b5e429ad4e0e38239845">grab</a> (<a class="el" href="classFl__Window.html">Fl_Window</a> *)</td></tr>
<tr class="memdesc:ga0918f4dabb87b5e429ad4e0e38239845"><td class="mdescLeft">&#160;</td><td class="mdescRight">Selects the window to grab.  <br /></td></tr>
<tr class="separator:ga0918f4dabb87b5e429ad4e0e38239845"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0a9410a98136445bacce42b2e3ad4e84" id="r_ga0a9410a98136445bacce42b2e3ad4e84"><td class="memItemLeft" align="right" valign="top">
static int&#160;</td><td class="memItemRight" valign="bottom"><b>h</b> ()</td></tr>
<tr class="memdesc:ga0a9410a98136445bacce42b2e3ad4e84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the height in pixels of the main screen work area. <br /></td></tr>
<tr class="separator:ga0a9410a98136445bacce42b2e3ad4e84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga064a4028b27d7da1238a6e5280582abf" id="r_ga064a4028b27d7da1238a6e5280582abf"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__events.html#ga064a4028b27d7da1238a6e5280582abf">handle</a> (int, <a class="el" href="classFl__Window.html">Fl_Window</a> *)</td></tr>
<tr class="memdesc:ga064a4028b27d7da1238a6e5280582abf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handle events from the window system.  <br /></td></tr>
<tr class="separator:ga064a4028b27d7da1238a6e5280582abf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9c55e69277a2197ca3763122ff2f78af" id="r_ga9c55e69277a2197ca3763122ff2f78af"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__events.html#ga9c55e69277a2197ca3763122ff2f78af">handle_</a> (int, <a class="el" href="classFl__Window.html">Fl_Window</a> *)</td></tr>
<tr class="memdesc:ga9c55e69277a2197ca3763122ff2f78af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handle events from the window system.  <br /></td></tr>
<tr class="separator:ga9c55e69277a2197ca3763122ff2f78af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ab2ac86a4368147c075dd6750b03546" id="r_a3ab2ac86a4368147c075dd6750b03546"><td class="memItemLeft" align="right" valign="top"><a id="a3ab2ac86a4368147c075dd6750b03546" name="a3ab2ac86a4368147c075dd6750b03546"></a>
static int&#160;</td><td class="memItemRight" valign="bottom"><b>has_check</b> (<a class="el" href="group__callback__functions.html#ga17b5c6570394124287997166a50ff07a">Fl_Timeout_Handler</a>, void *=0)</td></tr>
<tr class="memdesc:a3ab2ac86a4368147c075dd6750b03546"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns 1 if the check exists and has not been called yet, 0 otherwise. <br /></td></tr>
<tr class="separator:a3ab2ac86a4368147c075dd6750b03546"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41f5d04106f8369655e51bd27e4953cd" id="r_a41f5d04106f8369655e51bd27e4953cd"><td class="memItemLeft" align="right" valign="top"><a id="a41f5d04106f8369655e51bd27e4953cd" name="a41f5d04106f8369655e51bd27e4953cd"></a>
static int&#160;</td><td class="memItemRight" valign="bottom"><b>has_idle</b> (<a class="el" href="group__callback__functions.html#gac9d2aab1d3142308450e2da09716013e">Fl_Idle_Handler</a> cb, void *data=0)</td></tr>
<tr class="memdesc:a41f5d04106f8369655e51bd27e4953cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the specified idle callback is currently installed. <br /></td></tr>
<tr class="separator:a41f5d04106f8369655e51bd27e4953cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3164768ec950db81396b81ef42f8ba2" id="r_ae3164768ec950db81396b81ef42f8ba2"><td class="memItemLeft" align="right" valign="top"><a id="ae3164768ec950db81396b81ef42f8ba2" name="ae3164768ec950db81396b81ef42f8ba2"></a>
static int&#160;</td><td class="memItemRight" valign="bottom"><b>has_timeout</b> (<a class="el" href="group__callback__functions.html#ga17b5c6570394124287997166a50ff07a">Fl_Timeout_Handler</a>, void *=0)</td></tr>
<tr class="memdesc:ae3164768ec950db81396b81ef42f8ba2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the timeout exists and has not been called yet. <br /></td></tr>
<tr class="separator:ae3164768ec950db81396b81ef42f8ba2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19c26018ae654d07ec1aa73e35b244a4" id="r_a19c26018ae654d07ec1aa73e35b244a4"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl.html#a19c26018ae654d07ec1aa73e35b244a4">is_scheme</a> (const char *name)</td></tr>
<tr class="memdesc:a19c26018ae654d07ec1aa73e35b244a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the current scheme is the given name.  <br /></td></tr>
<tr class="separator:a19c26018ae654d07ec1aa73e35b244a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf6f46de66cc183bc5b38cd364aca4cf2" id="r_gaf6f46de66cc183bc5b38cd364aca4cf2"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__multithread.html#gaf6f46de66cc183bc5b38cd364aca4cf2">lock</a> ()</td></tr>
<tr class="memdesc:gaf6f46de66cc183bc5b38cd364aca4cf2"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="group__fl__multithread.html#gaf6f46de66cc183bc5b38cd364aca4cf2" title="The lock() method blocks the current thread until it can safely access FLTK widgets and data.">lock()</a> method blocks the current thread until it can safely access FLTK widgets and data.  <br /></td></tr>
<tr class="separator:gaf6f46de66cc183bc5b38cd364aca4cf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9af770aeddd6082c01c47a075ce6d33b" id="r_ga9af770aeddd6082c01c47a075ce6d33b"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classFl__Window.html">Fl_Window</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__windows.html#ga9af770aeddd6082c01c47a075ce6d33b">modal</a> ()</td></tr>
<tr class="memdesc:ga9af770aeddd6082c01c47a075ce6d33b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the top-most <a class="el" href="group__fl__windows.html#ga9af770aeddd6082c01c47a075ce6d33b" title="Returns the top-most modal() window currently shown.">modal()</a> window currently shown.  <br /></td></tr>
<tr class="separator:ga9af770aeddd6082c01c47a075ce6d33b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga46df67455d96ee45e51f59263c6bf0ea" id="r_ga46df67455d96ee45e51f59263c6bf0ea"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classFl__Window.html">Fl_Window</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__windows.html#ga46df67455d96ee45e51f59263c6bf0ea">next_window</a> (const <a class="el" href="classFl__Window.html">Fl_Window</a> *)</td></tr>
<tr class="memdesc:ga46df67455d96ee45e51f59263c6bf0ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the next top-level window in the list of shown() windows.  <br /></td></tr>
<tr class="separator:ga46df67455d96ee45e51f59263c6bf0ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc49722be45fb56cad89c7c067eda5e3" id="r_abc49722be45fb56cad89c7c067eda5e3"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl.html#abc49722be45fb56cad89c7c067eda5e3">option</a> (<a class="el" href="classFl.html#a43e6e0bbbc03cad134d928d4edd48d1d">Fl_Option</a> opt)</td></tr>
<tr class="memdesc:abc49722be45fb56cad89c7c067eda5e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">FLTK library options management.  <br /></td></tr>
<tr class="separator:abc49722be45fb56cad89c7c067eda5e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b040cad5d6fc04bb139877015091c16" id="r_a9b040cad5d6fc04bb139877015091c16"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl.html#a9b040cad5d6fc04bb139877015091c16">option</a> (<a class="el" href="classFl.html#a43e6e0bbbc03cad134d928d4edd48d1d">Fl_Option</a> opt, bool val)</td></tr>
<tr class="memdesc:a9b040cad5d6fc04bb139877015091c16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Override an option while the application is running.  <br /></td></tr>
<tr class="separator:a9b040cad5d6fc04bb139877015091c16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a217dd709bed0d62a652625d505918fc6" id="r_a217dd709bed0d62a652625d505918fc6"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl.html#a217dd709bed0d62a652625d505918fc6">own_colormap</a> ()</td></tr>
<tr class="memdesc:a217dd709bed0d62a652625d505918fc6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes FLTK use its <a href="fltk-colormap.png">own colormap</a>.  <br /></td></tr>
<tr class="separator:a217dd709bed0d62a652625d505918fc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9d5cf78a03d0d619052dea890d97c71e" id="r_ga9d5cf78a03d0d619052dea890d97c71e"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__clipboard.html#ga9d5cf78a03d0d619052dea890d97c71e">paste</a> (<a class="el" href="classFl__Widget.html">Fl_Widget</a> &amp;receiver)</td></tr>
<tr class="memdesc:ga9d5cf78a03d0d619052dea890d97c71e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Backward compatibility only.  <br /></td></tr>
<tr class="separator:ga9d5cf78a03d0d619052dea890d97c71e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0f30d10ec79056fbdbf8d2f4dca4d565" id="r_ga0f30d10ec79056fbdbf8d2f4dca4d565"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__clipboard.html#ga0f30d10ec79056fbdbf8d2f4dca4d565">paste</a> (<a class="el" href="classFl__Widget.html">Fl_Widget</a> &amp;receiver, int source, const char *type=<a class="el" href="group__fl__clipboard.html#ga96135e2dd04bfd737085ef5fb3d824e1">Fl::clipboard_plain_text</a>)</td></tr>
<tr class="memdesc:ga0f30d10ec79056fbdbf8d2f4dca4d565"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pastes the data from the selection buffer (<code>source</code> is 0) or the clipboard (<code>source</code> is 1) into <code>receiver</code>.  <br /></td></tr>
<tr class="separator:ga0f30d10ec79056fbdbf8d2f4dca4d565"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6216cd12be29cf0465c8e3bf8510cb2f" id="r_ga6216cd12be29cf0465c8e3bf8510cb2f"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classFl__Widget.html">Fl_Widget</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__events.html#ga6216cd12be29cf0465c8e3bf8510cb2f">pushed</a> ()</td></tr>
<tr class="memdesc:ga6216cd12be29cf0465c8e3bf8510cb2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the widget that is being pushed.  <br /></td></tr>
<tr class="separator:ga6216cd12be29cf0465c8e3bf8510cb2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga83b269dff4e6b30a876ec46b6f911fac" id="r_ga83b269dff4e6b30a876ec46b6f911fac"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__events.html#ga83b269dff4e6b30a876ec46b6f911fac">pushed</a> (<a class="el" href="classFl__Widget.html">Fl_Widget</a> *)</td></tr>
<tr class="memdesc:ga83b269dff4e6b30a876ec46b6f911fac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the widget that is being pushed.  <br /></td></tr>
<tr class="separator:ga83b269dff4e6b30a876ec46b6f911fac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c27ca2833030aa15482bd06dbfc5959" id="r_a3c27ca2833030aa15482bd06dbfc5959"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classFl__Widget.html">Fl_Widget</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl.html#a3c27ca2833030aa15482bd06dbfc5959">readqueue</a> ()</td></tr>
<tr class="memdesc:a3c27ca2833030aa15482bd06dbfc5959"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the default callback queue and returns the first widget.  <br /></td></tr>
<tr class="separator:a3c27ca2833030aa15482bd06dbfc5959"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41a0cf2dd925cc6c4074d32a36fcf98f" id="r_a41a0cf2dd925cc6c4074d32a36fcf98f"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl.html#a41a0cf2dd925cc6c4074d32a36fcf98f">ready</a> ()</td></tr>
<tr class="memdesc:a41a0cf2dd925cc6c4074d32a36fcf98f"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is similar to <a class="el" href="classFl.html#a1dbb83f1d52001c152ccf8415e3ee6f0" title="Same as Fl::wait(0).">Fl::check()</a> except this does <em>not</em> call <a class="el" href="classFl.html#a08d29d807ea3874b8bb16f7457f64bdc" title="Causes all the windows that need it to be redrawn and graphics forced out through the pipes.">Fl::flush()</a> or any callbacks, which is useful if your program is in a state where such callbacks are illegal.  <br /></td></tr>
<tr class="separator:a41a0cf2dd925cc6c4074d32a36fcf98f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeec5e7939d214882da2d31c894a5bad7" id="r_aeec5e7939d214882da2d31c894a5bad7"><td class="memItemLeft" align="right" valign="top"><a id="aeec5e7939d214882da2d31c894a5bad7" name="aeec5e7939d214882da2d31c894a5bad7"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><b>redraw</b> ()</td></tr>
<tr class="memdesc:aeec5e7939d214882da2d31c894a5bad7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Redraws all widgets. <br /></td></tr>
<tr class="separator:aeec5e7939d214882da2d31c894a5bad7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a656023b0db49ae9b88e277ccdb27ce1b" id="r_a656023b0db49ae9b88e277ccdb27ce1b"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl.html#a656023b0db49ae9b88e277ccdb27ce1b">release</a> ()</td></tr>
<tr class="memdesc:a656023b0db49ae9b88e277ccdb27ce1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Releases the current grabbed window, equals grab(0).  <br /></td></tr>
<tr class="separator:a656023b0db49ae9b88e277ccdb27ce1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1426329d09de561319d4555018d9d1a2" id="r_ga1426329d09de561319d4555018d9d1a2"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__del__widget.html#ga1426329d09de561319d4555018d9d1a2">release_widget_pointer</a> (<a class="el" href="classFl__Widget.html">Fl_Widget</a> *&amp;<a class="el" href="group__fl__screen.html#ga4fcd39428db4299026322c91715cf379">w</a>)</td></tr>
<tr class="memdesc:ga1426329d09de561319d4555018d9d1a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Releases a widget pointer from the watch list.  <br /></td></tr>
<tr class="separator:ga1426329d09de561319d4555018d9d1a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cf6b5b7bfe06b268e8c51ec11acf378" id="r_a3cf6b5b7bfe06b268e8c51ec11acf378"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl.html#a3cf6b5b7bfe06b268e8c51ec11acf378">reload_scheme</a> ()</td></tr>
<tr class="memdesc:a3cf6b5b7bfe06b268e8c51ec11acf378"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called by scheme according to scheme name.  <br /></td></tr>
<tr class="separator:a3cf6b5b7bfe06b268e8c51ec11acf378"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43ee3d6bb1c70f5202e7cc9cb87cd515" id="r_a43ee3d6bb1c70f5202e7cc9cb87cd515"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl.html#a43ee3d6bb1c70f5202e7cc9cb87cd515">remove_check</a> (<a class="el" href="group__callback__functions.html#ga17b5c6570394124287997166a50ff07a">Fl_Timeout_Handler</a>, void *=0)</td></tr>
<tr class="memdesc:a43ee3d6bb1c70f5202e7cc9cb87cd515"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes a check callback.  <br /></td></tr>
<tr class="separator:a43ee3d6bb1c70f5202e7cc9cb87cd515"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafd837e512f22cec57f6fad2362e27350" id="r_gafd837e512f22cec57f6fad2362e27350"><td class="memItemLeft" align="right" valign="top">
static void&#160;</td><td class="memItemRight" valign="bottom"><b>remove_clipboard_notify</b> (<a class="el" href="group__callback__functions.html#gae5e26cbad23960ff7ce4d50d82c74750">Fl_Clipboard_Notify_Handler</a> <a class="el" href="group__fl__screen.html#ga0a9410a98136445bacce42b2e3ad4e84">h</a>)</td></tr>
<tr class="memdesc:gafd837e512f22cec57f6fad2362e27350"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stop calling the specified callback when there are changes to the selection buffer or the clipboard. <br /></td></tr>
<tr class="separator:gafd837e512f22cec57f6fad2362e27350"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4254e8bc88b9d4cb3e66152ac4caee86" id="r_a4254e8bc88b9d4cb3e66152ac4caee86"><td class="memItemLeft" align="right" valign="top"><a id="a4254e8bc88b9d4cb3e66152ac4caee86" name="a4254e8bc88b9d4cb3e66152ac4caee86"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><b>remove_fd</b> (int)</td></tr>
<tr class="memdesc:a4254e8bc88b9d4cb3e66152ac4caee86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes a file descriptor handler. <br /></td></tr>
<tr class="separator:a4254e8bc88b9d4cb3e66152ac4caee86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c7766bf3e45e170fe1741e98092e55f" id="r_a1c7766bf3e45e170fe1741e98092e55f"><td class="memItemLeft" align="right" valign="top"><a id="a1c7766bf3e45e170fe1741e98092e55f" name="a1c7766bf3e45e170fe1741e98092e55f"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><b>remove_fd</b> (int, int when)</td></tr>
<tr class="memdesc:a1c7766bf3e45e170fe1741e98092e55f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes a file descriptor handler. <br /></td></tr>
<tr class="separator:a1c7766bf3e45e170fe1741e98092e55f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga057451b4da1df58193521d8206f29edf" id="r_ga057451b4da1df58193521d8206f29edf"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__events.html#ga057451b4da1df58193521d8206f29edf">remove_handler</a> (<a class="el" href="group__callback__functions.html#ga188f6b1dd8e78ccc91c013fe5c6bba74">Fl_Event_Handler</a> <a class="el" href="group__fl__screen.html#ga0a9410a98136445bacce42b2e3ad4e84">h</a>)</td></tr>
<tr class="memdesc:ga057451b4da1df58193521d8206f29edf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes a previously added event handler.  <br /></td></tr>
<tr class="separator:ga057451b4da1df58193521d8206f29edf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43903f998a07e1cca7ba199c8ed25d9b" id="r_a43903f998a07e1cca7ba199c8ed25d9b"><td class="memItemLeft" align="right" valign="top"><a id="a43903f998a07e1cca7ba199c8ed25d9b" name="a43903f998a07e1cca7ba199c8ed25d9b"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><b>remove_idle</b> (<a class="el" href="group__callback__functions.html#gac9d2aab1d3142308450e2da09716013e">Fl_Idle_Handler</a> cb, void *data=0)</td></tr>
<tr class="memdesc:a43903f998a07e1cca7ba199c8ed25d9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the specified idle callback, if it is installed. <br /></td></tr>
<tr class="separator:a43903f998a07e1cca7ba199c8ed25d9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad5de0c3883a255c20ef432031f8746a7" id="r_gad5de0c3883a255c20ef432031f8746a7"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__events.html#gad5de0c3883a255c20ef432031f8746a7">remove_system_handler</a> (<a class="el" href="group__callback__functions.html#ga0cd86d9a18073304779213e82747ac8a">Fl_System_Handler</a> <a class="el" href="group__fl__screen.html#ga0a9410a98136445bacce42b2e3ad4e84">h</a>)</td></tr>
<tr class="memdesc:gad5de0c3883a255c20ef432031f8746a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes a previously added system event handler.  <br /></td></tr>
<tr class="separator:gad5de0c3883a255c20ef432031f8746a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a950f0585de6416eb4fee2365a1578f" id="r_a9a950f0585de6416eb4fee2365a1578f"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl.html#a9a950f0585de6416eb4fee2365a1578f">remove_timeout</a> (<a class="el" href="group__callback__functions.html#ga17b5c6570394124287997166a50ff07a">Fl_Timeout_Handler</a>, void *=0)</td></tr>
<tr class="memdesc:a9a950f0585de6416eb4fee2365a1578f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes a timeout callback.  <br /></td></tr>
<tr class="separator:a9a950f0585de6416eb4fee2365a1578f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5373d1d50c2b0ba38280d78bb6d2628" id="r_ae5373d1d50c2b0ba38280d78bb6d2628"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl.html#ae5373d1d50c2b0ba38280d78bb6d2628">repeat_timeout</a> (double t, <a class="el" href="group__callback__functions.html#ga17b5c6570394124287997166a50ff07a">Fl_Timeout_Handler</a>, void *=0)</td></tr>
<tr class="memdesc:ae5373d1d50c2b0ba38280d78bb6d2628"><td class="mdescLeft">&#160;</td><td class="mdescRight">Repeats a timeout callback from the expiration of the previous timeout, allowing for more accurate timing.  <br /></td></tr>
<tr class="separator:ae5373d1d50c2b0ba38280d78bb6d2628"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a3b1236b41800d24267288c564b187a" id="r_a7a3b1236b41800d24267288c564b187a"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl.html#a7a3b1236b41800d24267288c564b187a">run</a> ()</td></tr>
<tr class="memdesc:a7a3b1236b41800d24267288c564b187a"><td class="mdescLeft">&#160;</td><td class="mdescRight">As long as any windows are displayed this calls <a class="el" href="classFl.html#a108a84216f0b3fa1cb0c46ab7449a312" title="Waits until &quot;something happens&quot; and then returns.">Fl::wait()</a> repeatedly.  <br /></td></tr>
<tr class="separator:a7a3b1236b41800d24267288c564b187a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fb645ed69b6be60ff971b58a20853ec" id="r_a1fb645ed69b6be60ff971b58a20853ec"><td class="memItemLeft" align="right" valign="top"><a id="a1fb645ed69b6be60ff971b58a20853ec" name="a1fb645ed69b6be60ff971b58a20853ec"></a>
static const char *&#160;</td><td class="memItemRight" valign="bottom"><b>scheme</b> ()</td></tr>
<tr class="memdesc:a1fb645ed69b6be60ff971b58a20853ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">See void <a class="el" href="classFl.html#a9d070bb1d5a24c28beab53a70af095a4" title="Sets the current widget scheme.">scheme(const char *name)</a> <br /></td></tr>
<tr class="separator:a1fb645ed69b6be60ff971b58a20853ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d070bb1d5a24c28beab53a70af095a4" id="r_a9d070bb1d5a24c28beab53a70af095a4"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl.html#a9d070bb1d5a24c28beab53a70af095a4">scheme</a> (const char *name)</td></tr>
<tr class="memdesc:a9d070bb1d5a24c28beab53a70af095a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the current widget scheme.  <br /></td></tr>
<tr class="separator:a9d070bb1d5a24c28beab53a70af095a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaa65116ad458fcb4a71c2f374de5dcd9" id="r_gaaa65116ad458fcb4a71c2f374de5dcd9"><td class="memItemLeft" align="right" valign="top">
static int&#160;</td><td class="memItemRight" valign="bottom"><b>screen_count</b> ()</td></tr>
<tr class="memdesc:gaaa65116ad458fcb4a71c2f374de5dcd9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the number of available screens. <br /></td></tr>
<tr class="separator:gaaa65116ad458fcb4a71c2f374de5dcd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1a2c5b6e73b53eb3d99ae34cd35c07cd" id="r_ga1a2c5b6e73b53eb3d99ae34cd35c07cd"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__screen.html#ga1a2c5b6e73b53eb3d99ae34cd35c07cd">screen_dpi</a> (float &amp;<a class="el" href="group__fl__screen.html#ga0a9410a98136445bacce42b2e3ad4e84">h</a>, float &amp;v, int n=0)</td></tr>
<tr class="memdesc:ga1a2c5b6e73b53eb3d99ae34cd35c07cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the screen resolution in dots-per-inch for the given screen.  <br /></td></tr>
<tr class="separator:ga1a2c5b6e73b53eb3d99ae34cd35c07cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2a4ac46378ac0ed7e8b01927f88f3e8b" id="r_ga2a4ac46378ac0ed7e8b01927f88f3e8b"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__screen.html#ga2a4ac46378ac0ed7e8b01927f88f3e8b">screen_num</a> (int <a class="el" href="group__fl__screen.html#ga129f4b9d14ad1d720d60b7881693d6ec">x</a>, int <a class="el" href="group__fl__screen.html#ga6c89bea45612ee83941e879b3396d3a5">y</a>)</td></tr>
<tr class="memdesc:ga2a4ac46378ac0ed7e8b01927f88f3e8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the screen number of a screen that contains the specified screen position <code>x</code>, <code>y</code>.  <br /></td></tr>
<tr class="separator:ga2a4ac46378ac0ed7e8b01927f88f3e8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga17da7e7c9cd5f8bb44e352910ce6cee8" id="r_ga17da7e7c9cd5f8bb44e352910ce6cee8"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__screen.html#ga17da7e7c9cd5f8bb44e352910ce6cee8">screen_num</a> (int <a class="el" href="group__fl__screen.html#ga129f4b9d14ad1d720d60b7881693d6ec">x</a>, int <a class="el" href="group__fl__screen.html#ga6c89bea45612ee83941e879b3396d3a5">y</a>, int <a class="el" href="group__fl__screen.html#ga4fcd39428db4299026322c91715cf379">w</a>, int <a class="el" href="group__fl__screen.html#ga0a9410a98136445bacce42b2e3ad4e84">h</a>)</td></tr>
<tr class="memdesc:ga17da7e7c9cd5f8bb44e352910ce6cee8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the screen number for the screen which intersects the most with the rectangle defined by <code>x</code>, <code>y</code>, <code>w</code>, <code>h</code>.  <br /></td></tr>
<tr class="separator:ga17da7e7c9cd5f8bb44e352910ce6cee8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf5d57c7b30d0b6e8adaa44027b89255e" id="r_gaf5d57c7b30d0b6e8adaa44027b89255e"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__screen.html#gaf5d57c7b30d0b6e8adaa44027b89255e">screen_work_area</a> (int &amp;X, int &amp;Y, int &amp;W, int &amp;H)</td></tr>
<tr class="memdesc:gaf5d57c7b30d0b6e8adaa44027b89255e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the bounding box of the work area of the screen that contains the mouse pointer.  <br /></td></tr>
<tr class="separator:gaf5d57c7b30d0b6e8adaa44027b89255e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0dc1a0cf192a9e4376932a595003a89e" id="r_ga0dc1a0cf192a9e4376932a595003a89e"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__screen.html#ga0dc1a0cf192a9e4376932a595003a89e">screen_work_area</a> (int &amp;X, int &amp;Y, int &amp;W, int &amp;H, int mx, int my)</td></tr>
<tr class="memdesc:ga0dc1a0cf192a9e4376932a595003a89e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the bounding box of the work area of a screen that contains the specified screen position <code>mx</code>, <code>my</code>.  <br /></td></tr>
<tr class="separator:ga0dc1a0cf192a9e4376932a595003a89e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1b6d4dd670d06cd76ed0f3891ae80219" id="r_ga1b6d4dd670d06cd76ed0f3891ae80219"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__screen.html#ga1b6d4dd670d06cd76ed0f3891ae80219">screen_work_area</a> (int &amp;X, int &amp;Y, int &amp;W, int &amp;H, int n)</td></tr>
<tr class="memdesc:ga1b6d4dd670d06cd76ed0f3891ae80219"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the bounding box of the work area of the given screen.  <br /></td></tr>
<tr class="separator:ga1b6d4dd670d06cd76ed0f3891ae80219"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga510d26cb2d6ec0688cf1eb8c5d9e5a1e" id="r_ga510d26cb2d6ec0688cf1eb8c5d9e5a1e"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__screen.html#ga510d26cb2d6ec0688cf1eb8c5d9e5a1e">screen_xywh</a> (int &amp;X, int &amp;Y, int &amp;W, int &amp;H)</td></tr>
<tr class="memdesc:ga510d26cb2d6ec0688cf1eb8c5d9e5a1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the bounding box of a screen that contains the mouse pointer.  <br /></td></tr>
<tr class="separator:ga510d26cb2d6ec0688cf1eb8c5d9e5a1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaba4caf50886ae88df6a957b8748ea113" id="r_gaba4caf50886ae88df6a957b8748ea113"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__screen.html#gaba4caf50886ae88df6a957b8748ea113">screen_xywh</a> (int &amp;X, int &amp;Y, int &amp;W, int &amp;H, int mx, int my)</td></tr>
<tr class="memdesc:gaba4caf50886ae88df6a957b8748ea113"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the bounding box of a screen that contains the specified screen position <code>mx</code>, <code>my</code>.  <br /></td></tr>
<tr class="separator:gaba4caf50886ae88df6a957b8748ea113"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabe29a526a41ffb5df1c5116cf61ead54" id="r_gabe29a526a41ffb5df1c5116cf61ead54"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__screen.html#gabe29a526a41ffb5df1c5116cf61ead54">screen_xywh</a> (int &amp;X, int &amp;Y, int &amp;W, int &amp;H, int mx, int my, int mw, int mh)</td></tr>
<tr class="memdesc:gabe29a526a41ffb5df1c5116cf61ead54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the screen bounding rect for the screen which intersects the most with the rectangle defined by <code>mx</code>, <code>my</code>, <code>mw</code>, <code>mh</code>.  <br /></td></tr>
<tr class="separator:gabe29a526a41ffb5df1c5116cf61ead54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab52242843912b524e4a083e3272a2009" id="r_gab52242843912b524e4a083e3272a2009"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__screen.html#gab52242843912b524e4a083e3272a2009">screen_xywh</a> (int &amp;X, int &amp;Y, int &amp;W, int &amp;H, int n)</td></tr>
<tr class="memdesc:gab52242843912b524e4a083e3272a2009"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the screen bounding rect for the given screen.  <br /></td></tr>
<tr class="separator:gab52242843912b524e4a083e3272a2009"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82c225037f05d07a7797da5eddafb33a" id="r_a82c225037f05d07a7797da5eddafb33a"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl.html#a82c225037f05d07a7797da5eddafb33a">scrollbar_size</a> ()</td></tr>
<tr class="memdesc:a82c225037f05d07a7797da5eddafb33a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the default scrollbar size used by <a class="el" href="classFl__Browser__.html" title="This is the base class for browsers.">Fl_Browser_</a>, <a class="el" href="classFl__Help__View.html" title="The Fl_Help_View widget displays HTML text.">Fl_Help_View</a>, <a class="el" href="classFl__Scroll.html" title="This container widget lets you maneuver around a set of widgets much larger than your window.">Fl_Scroll</a>, and <a class="el" href="classFl__Text__Display.html" title="Rich text display widget.">Fl_Text_Display</a> widgets.  <br /></td></tr>
<tr class="separator:a82c225037f05d07a7797da5eddafb33a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6d2b6e0d640b81c6ec44d0164ec0f91" id="r_aa6d2b6e0d640b81c6ec44d0164ec0f91"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl.html#aa6d2b6e0d640b81c6ec44d0164ec0f91">scrollbar_size</a> (int W)</td></tr>
<tr class="memdesc:aa6d2b6e0d640b81c6ec44d0164ec0f91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the default scrollbar size that is used by the <a class="el" href="classFl__Browser__.html" title="This is the base class for browsers.">Fl_Browser_</a>, <a class="el" href="classFl__Help__View.html" title="The Fl_Help_View widget displays HTML text.">Fl_Help_View</a>, <a class="el" href="classFl__Scroll.html" title="This container widget lets you maneuver around a set of widgets much larger than your window.">Fl_Scroll</a>, and <a class="el" href="classFl__Text__Display.html" title="Rich text display widget.">Fl_Text_Display</a> widgets.  <br /></td></tr>
<tr class="separator:aa6d2b6e0d640b81c6ec44d0164ec0f91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac2993c9b0292c636357b1268fb63e827" id="r_gac2993c9b0292c636357b1268fb63e827"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__clipboard.html#gac2993c9b0292c636357b1268fb63e827">selection</a> (<a class="el" href="classFl__Widget.html">Fl_Widget</a> &amp;owner, const char *, int len)</td></tr>
<tr class="memdesc:gac2993c9b0292c636357b1268fb63e827"><td class="mdescLeft">&#160;</td><td class="mdescRight">Changes the current selection.  <br /></td></tr>
<tr class="separator:gac2993c9b0292c636357b1268fb63e827"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3b54f84c95f68efe1c8cf9e0121fdaf8" id="r_ga3b54f84c95f68efe1c8cf9e0121fdaf8"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classFl__Widget.html">Fl_Widget</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__clipboard.html#ga3b54f84c95f68efe1c8cf9e0121fdaf8">selection_owner</a> ()</td></tr>
<tr class="memdesc:ga3b54f84c95f68efe1c8cf9e0121fdaf8"><td class="mdescLeft">&#160;</td><td class="mdescRight">back-compatibility only: Gets the widget owning the current selection <br  />
  <br /></td></tr>
<tr class="separator:ga3b54f84c95f68efe1c8cf9e0121fdaf8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaec21e41f0909a27c9906e1a12aee319b" id="r_gaec21e41f0909a27c9906e1a12aee319b"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__clipboard.html#gaec21e41f0909a27c9906e1a12aee319b">selection_owner</a> (<a class="el" href="classFl__Widget.html">Fl_Widget</a> *)</td></tr>
<tr class="memdesc:gaec21e41f0909a27c9906e1a12aee319b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Back-compatibility only: The single-argument call can be used to move the selection to another widget or to set the owner to NULL, without changing the actual text of the selection.  <br /></td></tr>
<tr class="separator:gaec21e41f0909a27c9906e1a12aee319b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa52e562142bd1e8d5ba6915ff5577245" id="r_gaa52e562142bd1e8d5ba6915ff5577245"><td class="memItemLeft" align="right" valign="top">
static void&#160;</td><td class="memItemRight" valign="bottom"><b>set_abort</b> (<a class="el" href="group__callback__functions.html#gab06d501e53b8fe82de6d70937fb22f95">Fl_Abort_Handler</a> f)</td></tr>
<tr class="memdesc:gaa52e562142bd1e8d5ba6915ff5577245"><td class="mdescLeft">&#160;</td><td class="mdescRight">For back compatibility, sets the void <a class="el" href="group__group__comdlg.html#ga181c7012ef5dd3a551a4e861c9fc974a" title="FLTK calls Fl::fatal() to output a fatal error message.">Fl::fatal</a> handler callback. <br /></td></tr>
<tr class="separator:gaa52e562142bd1e8d5ba6915ff5577245"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafe2b995bdaf60c5a5b2326e8845897c9" id="r_gafe2b995bdaf60c5a5b2326e8845897c9"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__windows.html#gafe2b995bdaf60c5a5b2326e8845897c9">set_atclose</a> (<a class="el" href="group__callback__functions.html#gac2b36f6e136744adb3e3ec87e068c169">Fl_Atclose_Handler</a> f)</td></tr>
<tr class="memdesc:gafe2b995bdaf60c5a5b2326e8845897c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">For back compatibility, sets the <a class="el" href="group__fl__windows.html#ga51afae3e9f75ffb9bbac49844195715c" title="Back compatibility: default window callback handler.">Fl::atclose</a> handler callback.  <br /></td></tr>
<tr class="separator:gafe2b995bdaf60c5a5b2326e8845897c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae41fc4e972e6c2056529e0d393141147" id="r_ae41fc4e972e6c2056529e0d393141147"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl.html#ae41fc4e972e6c2056529e0d393141147">set_box_color</a> (<a class="el" href="Enumerations_8H.html#a8b762953646f8abee866061f1af78a6a">Fl_Color</a>)</td></tr>
<tr class="memdesc:ae41fc4e972e6c2056529e0d393141147"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the drawing color for the box that is currently drawn.  <br /></td></tr>
<tr class="separator:ae41fc4e972e6c2056529e0d393141147"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73e0e8fefe8707817ca6fd6437c4869b" id="r_a73e0e8fefe8707817ca6fd6437c4869b"><td class="memItemLeft" align="right" valign="top"><a id="a73e0e8fefe8707817ca6fd6437c4869b" name="a73e0e8fefe8707817ca6fd6437c4869b"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><b>set_boxtype</b> (<a class="el" href="Enumerations_8H.html#ae48bf9070f8541de17829f54ccacc6bc">Fl_Boxtype</a>, <a class="el" href="group__callback__functions.html#gacb24a62f521a0e02cd7872a3bfbf3855">Fl_Box_Draw_F</a> *, <a class="el" href="fl__types_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a>, <a class="el" href="fl__types_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a>, <a class="el" href="fl__types_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a>, <a class="el" href="fl__types_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a>)</td></tr>
<tr class="memdesc:a73e0e8fefe8707817ca6fd6437c4869b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the function to call to draw a specific boxtype. <br /></td></tr>
<tr class="separator:a73e0e8fefe8707817ca6fd6437c4869b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a337397ba0fb948633c83ad7c39a67e00" id="r_a337397ba0fb948633c83ad7c39a67e00"><td class="memItemLeft" align="right" valign="top"><a id="a337397ba0fb948633c83ad7c39a67e00" name="a337397ba0fb948633c83ad7c39a67e00"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><b>set_boxtype</b> (<a class="el" href="Enumerations_8H.html#ae48bf9070f8541de17829f54ccacc6bc">Fl_Boxtype</a>, <a class="el" href="Enumerations_8H.html#ae48bf9070f8541de17829f54ccacc6bc">Fl_Boxtype</a> from)</td></tr>
<tr class="memdesc:a337397ba0fb948633c83ad7c39a67e00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the from boxtype. <br /></td></tr>
<tr class="separator:a337397ba0fb948633c83ad7c39a67e00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa6a6050ee3979754023eb1e66976240d" id="r_gaa6a6050ee3979754023eb1e66976240d"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__attributes.html#gaa6a6050ee3979754023eb1e66976240d">set_color</a> (<a class="el" href="Enumerations_8H.html#a8b762953646f8abee866061f1af78a6a">Fl_Color</a> i, unsigned c)</td></tr>
<tr class="memdesc:gaa6a6050ee3979754023eb1e66976240d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets an entry in the fl_color index table.  <br /></td></tr>
<tr class="separator:gaa6a6050ee3979754023eb1e66976240d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac62f634ba8089a9d0e48bf57154c61b0" id="r_gac62f634ba8089a9d0e48bf57154c61b0"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__attributes.html#gac62f634ba8089a9d0e48bf57154c61b0">set_color</a> (<a class="el" href="Enumerations_8H.html#a8b762953646f8abee866061f1af78a6a">Fl_Color</a>, <a class="el" href="fl__types_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a>, <a class="el" href="fl__types_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a>, <a class="el" href="fl__types_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a>)</td></tr>
<tr class="memdesc:gac62f634ba8089a9d0e48bf57154c61b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets an entry in the fl_color index table.  <br /></td></tr>
<tr class="separator:gac62f634ba8089a9d0e48bf57154c61b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga15dee80a622a9ab2798acfdc0aabcd95" id="r_ga15dee80a622a9ab2798acfdc0aabcd95"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__attributes.html#ga15dee80a622a9ab2798acfdc0aabcd95">set_font</a> (<a class="el" href="Enumerations_8H.html#a2ac46d9f082834b969fffe490a03a709">Fl_Font</a>, const char *)</td></tr>
<tr class="memdesc:ga15dee80a622a9ab2798acfdc0aabcd95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Changes a face.  <br /></td></tr>
<tr class="separator:ga15dee80a622a9ab2798acfdc0aabcd95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gace5762f829e283f7965eca8d70042a32" id="r_gace5762f829e283f7965eca8d70042a32"><td class="memItemLeft" align="right" valign="top">
static void&#160;</td><td class="memItemRight" valign="bottom"><b>set_font</b> (<a class="el" href="Enumerations_8H.html#a2ac46d9f082834b969fffe490a03a709">Fl_Font</a>, <a class="el" href="Enumerations_8H.html#a2ac46d9f082834b969fffe490a03a709">Fl_Font</a>)</td></tr>
<tr class="memdesc:gace5762f829e283f7965eca8d70042a32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies one face to another. <br /></td></tr>
<tr class="separator:gace5762f829e283f7965eca8d70042a32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadfa546e0caa16420399c3202fd75efd4" id="r_gadfa546e0caa16420399c3202fd75efd4"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="Enumerations_8H.html#a2ac46d9f082834b969fffe490a03a709">Fl_Font</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__attributes.html#gadfa546e0caa16420399c3202fd75efd4">set_fonts</a> (const char *=0)</td></tr>
<tr class="memdesc:gadfa546e0caa16420399c3202fd75efd4"><td class="mdescLeft">&#160;</td><td class="mdescRight">FLTK will open the display, and add every fonts on the server to the face table.  <br /></td></tr>
<tr class="separator:gadfa546e0caa16420399c3202fd75efd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77955ad2f2b83fc5e3925b94e4533b20" id="r_a77955ad2f2b83fc5e3925b94e4533b20"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl.html#a77955ad2f2b83fc5e3925b94e4533b20">set_idle</a> (<a class="el" href="group__callback__functions.html#ga238786923bf2e91732a7305fc0647dbf">Fl_Old_Idle_Handler</a> cb)</td></tr>
<tr class="memdesc:a77955ad2f2b83fc5e3925b94e4533b20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets an idle callback.  <br /></td></tr>
<tr class="separator:a77955ad2f2b83fc5e3925b94e4533b20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2041799ff3f57f4cced52d7e3b3a544a" id="r_a2041799ff3f57f4cced52d7e3b3a544a"><td class="memItemLeft" align="right" valign="top"><a id="a2041799ff3f57f4cced52d7e3b3a544a" name="a2041799ff3f57f4cced52d7e3b3a544a"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><b>set_labeltype</b> (<a class="el" href="Enumerations_8H.html#ad5774781d33328b82990ff9e25dfd61b">Fl_Labeltype</a>, <a class="el" href="group__callback__functions.html#ga569530b250a4e2f56022249512687a0c">Fl_Label_Draw_F</a> *, <a class="el" href="group__callback__functions.html#ga946140c0dcd42dbef9f134af6f2da17b">Fl_Label_Measure_F</a> *)</td></tr>
<tr class="memdesc:a2041799ff3f57f4cced52d7e3b3a544a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the functions to call to draw and measure a specific labeltype. <br /></td></tr>
<tr class="separator:a2041799ff3f57f4cced52d7e3b3a544a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1633da3e36598ebe875f0c16fc9f198" id="r_ad1633da3e36598ebe875f0c16fc9f198"><td class="memItemLeft" align="right" valign="top"><a id="ad1633da3e36598ebe875f0c16fc9f198" name="ad1633da3e36598ebe875f0c16fc9f198"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><b>set_labeltype</b> (<a class="el" href="Enumerations_8H.html#ad5774781d33328b82990ff9e25dfd61b">Fl_Labeltype</a>, <a class="el" href="Enumerations_8H.html#ad5774781d33328b82990ff9e25dfd61b">Fl_Labeltype</a> from)</td></tr>
<tr class="memdesc:ad1633da3e36598ebe875f0c16fc9f198"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the functions to call to draw and measure a specific labeltype. <br /></td></tr>
<tr class="separator:ad1633da3e36598ebe875f0c16fc9f198"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab8b767183ac691d4249f599b94dafe78" id="r_gab8b767183ac691d4249f599b94dafe78"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__events.html#gab8b767183ac691d4249f599b94dafe78">test_shortcut</a> (<a class="el" href="fl__types_8h.html#a37ec1cd050a604a45dff00efba45609d">Fl_Shortcut</a>)</td></tr>
<tr class="memdesc:gab8b767183ac691d4249f599b94dafe78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests the current event, which must be an FL_KEYBOARD or FL_SHORTCUT, against a shortcut value (described in <a class="el" href="classFl__Button.html" title="Buttons generate callbacks when they are clicked by the user.">Fl_Button</a>).  <br /></td></tr>
<tr class="separator:gab8b767183ac691d4249f599b94dafe78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga82258694ec1baf11c3756c965b2c501e" id="r_ga82258694ec1baf11c3756c965b2c501e"><td class="memItemLeft" align="right" valign="top">static void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__multithread.html#ga82258694ec1baf11c3756c965b2c501e">thread_message</a> ()</td></tr>
<tr class="memdesc:ga82258694ec1baf11c3756c965b2c501e"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="group__fl__multithread.html#ga82258694ec1baf11c3756c965b2c501e" title="The thread_message() method returns the last message that was sent from a child by the awake() method...">thread_message()</a> method returns the last message that was sent from a child by the <a class="el" href="group__fl__multithread.html#gae9e8f440ce2ca05b047c620f75af13cb" title="Sends a message pointer to the main thread, causing any pending Fl::wait() call to terminate so that ...">awake()</a> method.  <br /></td></tr>
<tr class="separator:ga82258694ec1baf11c3756c965b2c501e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2b9375cc078d9d39161e2cba520829fd" id="r_ga2b9375cc078d9d39161e2cba520829fd"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__multithread.html#ga2b9375cc078d9d39161e2cba520829fd">unlock</a> ()</td></tr>
<tr class="memdesc:ga2b9375cc078d9d39161e2cba520829fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="group__fl__multithread.html#ga2b9375cc078d9d39161e2cba520829fd" title="The unlock() method releases the lock that was set using the lock() method.">unlock()</a> method releases the lock that was set using the <a class="el" href="group__fl__multithread.html#gaf6f46de66cc183bc5b38cd364aca4cf2" title="The lock() method blocks the current thread until it can safely access FLTK widgets and data.">lock()</a> method.  <br /></td></tr>
<tr class="separator:ga2b9375cc078d9d39161e2cba520829fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a841e929912f3604e0a3d0ef1dff245c8" id="r_a841e929912f3604e0a3d0ef1dff245c8"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl.html#a841e929912f3604e0a3d0ef1dff245c8">use_high_res_GL</a> ()</td></tr>
<tr class="memdesc:a841e929912f3604e0a3d0ef1dff245c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns whether GL windows should be drawn at high resolution on Apple computers with retina displays.  <br /></td></tr>
<tr class="separator:a841e929912f3604e0a3d0ef1dff245c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f52e1de14ecab5166a921640fbee640" id="r_a3f52e1de14ecab5166a921640fbee640"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl.html#a3f52e1de14ecab5166a921640fbee640">use_high_res_GL</a> (int val)</td></tr>
<tr class="memdesc:a3f52e1de14ecab5166a921640fbee640"><td class="mdescLeft">&#160;</td><td class="mdescRight">sets whether GL windows should be drawn at high resolution on Apple computers with retina displays  <br /></td></tr>
<tr class="separator:a3f52e1de14ecab5166a921640fbee640"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad65803adc5e4936111bd31a52f1d61a7" id="r_ad65803adc5e4936111bd31a52f1d61a7"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl.html#ad65803adc5e4936111bd31a52f1d61a7">version</a> ()</td></tr>
<tr class="memdesc:ad65803adc5e4936111bd31a52f1d61a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the compiled-in value of the FL_VERSION constant.  <br /></td></tr>
<tr class="separator:ad65803adc5e4936111bd31a52f1d61a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9eaddd02a0aa637078ee2dd80b85b2f" id="r_ae9eaddd02a0aa637078ee2dd80b85b2f"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl.html#ae9eaddd02a0aa637078ee2dd80b85b2f">visible_focus</a> ()</td></tr>
<tr class="memdesc:ae9eaddd02a0aa637078ee2dd80b85b2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets or sets the visible keyboard focus on buttons and other non-text widgets.  <br /></td></tr>
<tr class="separator:ae9eaddd02a0aa637078ee2dd80b85b2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade5fd097d36257dce2b7aff1165e037f" id="r_ade5fd097d36257dce2b7aff1165e037f"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl.html#ade5fd097d36257dce2b7aff1165e037f">visible_focus</a> (int v)</td></tr>
<tr class="memdesc:ade5fd097d36257dce2b7aff1165e037f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets or sets the visible keyboard focus on buttons and other non-text widgets.  <br /></td></tr>
<tr class="separator:ade5fd097d36257dce2b7aff1165e037f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d6deb3d4f76b538d508b36700dfb6b0" id="r_a6d6deb3d4f76b538d508b36700dfb6b0"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl.html#a6d6deb3d4f76b538d508b36700dfb6b0">visual</a> (int)</td></tr>
<tr class="memdesc:a6d6deb3d4f76b538d508b36700dfb6b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Selects a visual so that your graphics are drawn correctly.  <br /></td></tr>
<tr class="separator:a6d6deb3d4f76b538d508b36700dfb6b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4fcd39428db4299026322c91715cf379" id="r_ga4fcd39428db4299026322c91715cf379"><td class="memItemLeft" align="right" valign="top">
static int&#160;</td><td class="memItemRight" valign="bottom"><b>w</b> ()</td></tr>
<tr class="memdesc:ga4fcd39428db4299026322c91715cf379"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the width in pixels of the main screen work area. <br /></td></tr>
<tr class="separator:ga4fcd39428db4299026322c91715cf379"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a108a84216f0b3fa1cb0c46ab7449a312" id="r_a108a84216f0b3fa1cb0c46ab7449a312"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl.html#a108a84216f0b3fa1cb0c46ab7449a312">wait</a> ()</td></tr>
<tr class="memdesc:a108a84216f0b3fa1cb0c46ab7449a312"><td class="mdescLeft">&#160;</td><td class="mdescRight">Waits until "something happens" and then returns.  <br /></td></tr>
<tr class="separator:a108a84216f0b3fa1cb0c46ab7449a312"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af49654e35a0b636aa751dce5ff88a7f5" id="r_af49654e35a0b636aa751dce5ff88a7f5"><td class="memItemLeft" align="right" valign="top"><a id="af49654e35a0b636aa751dce5ff88a7f5" name="af49654e35a0b636aa751dce5ff88a7f5"></a>
static double&#160;</td><td class="memItemRight" valign="bottom"><b>wait</b> (double time)</td></tr>
<tr class="memdesc:af49654e35a0b636aa751dce5ff88a7f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">See int <a class="el" href="classFl.html#a108a84216f0b3fa1cb0c46ab7449a312" title="Waits until &quot;something happens&quot; and then returns.">Fl::wait()</a> <br /></td></tr>
<tr class="separator:af49654e35a0b636aa751dce5ff88a7f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga16ecd6d20b793fd0f3081eaab369caa9" id="r_ga16ecd6d20b793fd0f3081eaab369caa9"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__del__widget.html#ga16ecd6d20b793fd0f3081eaab369caa9">watch_widget_pointer</a> (<a class="el" href="classFl__Widget.html">Fl_Widget</a> *&amp;<a class="el" href="group__fl__screen.html#ga4fcd39428db4299026322c91715cf379">w</a>)</td></tr>
<tr class="memdesc:ga16ecd6d20b793fd0f3081eaab369caa9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a widget pointer to the widget watch list.  <br /></td></tr>
<tr class="separator:ga16ecd6d20b793fd0f3081eaab369caa9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga129f4b9d14ad1d720d60b7881693d6ec" id="r_ga129f4b9d14ad1d720d60b7881693d6ec"><td class="memItemLeft" align="right" valign="top">
static int&#160;</td><td class="memItemRight" valign="bottom"><b>x</b> ()</td></tr>
<tr class="memdesc:ga129f4b9d14ad1d720d60b7881693d6ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the leftmost x coordinate of the main screen work area. <br /></td></tr>
<tr class="separator:ga129f4b9d14ad1d720d60b7881693d6ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6c89bea45612ee83941e879b3396d3a5" id="r_ga6c89bea45612ee83941e879b3396d3a5"><td class="memItemLeft" align="right" valign="top">
static int&#160;</td><td class="memItemRight" valign="bottom"><b>y</b> ()</td></tr>
<tr class="memdesc:ga6c89bea45612ee83941e879b3396d3a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the topmost y coordinate of the main screen work area. <br /></td></tr>
<tr class="separator:ga6c89bea45612ee83941e879b3396d3a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-attribs" name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:ga51afae3e9f75ffb9bbac49844195715c" id="r_ga51afae3e9f75ffb9bbac49844195715c"><td class="memItemLeft" align="right" valign="top">static void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__windows.html#ga51afae3e9f75ffb9bbac49844195715c">atclose</a> )(<a class="el" href="classFl__Window.html">Fl_Window</a> *, void *)</td></tr>
<tr class="memdesc:ga51afae3e9f75ffb9bbac49844195715c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Back compatibility: default window callback handler.  <br /></td></tr>
<tr class="separator:ga51afae3e9f75ffb9bbac49844195715c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2f1a7a0f0cd1fa222b6042f7dce4b65d" id="r_ga2f1a7a0f0cd1fa222b6042f7dce4b65d"><td class="memItemLeft" align="right" valign="top">
static char const  *const&#160;</td><td class="memItemRight" valign="bottom"><b>clipboard_image</b> = &quot;image&quot;</td></tr>
<tr class="memdesc:ga2f1a7a0f0cd1fa222b6042f7dce4b65d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Denotes image data. <br /></td></tr>
<tr class="separator:ga2f1a7a0f0cd1fa222b6042f7dce4b65d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga96135e2dd04bfd737085ef5fb3d824e1" id="r_ga96135e2dd04bfd737085ef5fb3d824e1"><td class="memItemLeft" align="right" valign="top">
static char const  *const&#160;</td><td class="memItemRight" valign="bottom"><b>clipboard_plain_text</b> = &quot;text/plain&quot;</td></tr>
<tr class="memdesc:ga96135e2dd04bfd737085ef5fb3d824e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Denotes plain textual data. <br /></td></tr>
<tr class="separator:ga96135e2dd04bfd737085ef5fb3d824e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga163461446c664de8d1785ee0e4515f23" id="r_ga163461446c664de8d1785ee0e4515f23"><td class="memItemLeft" align="right" valign="top">static void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__comdlg.html#ga163461446c664de8d1785ee0e4515f23">error</a> )(const char *,...) = ::error</td></tr>
<tr class="memdesc:ga163461446c664de8d1785ee0e4515f23"><td class="mdescLeft">&#160;</td><td class="mdescRight">FLTK calls <a class="el" href="group__group__comdlg.html#ga163461446c664de8d1785ee0e4515f23" title="FLTK calls Fl::error() to output a normal error message.">Fl::error()</a> to output a normal error message.  <br /></td></tr>
<tr class="separator:ga163461446c664de8d1785ee0e4515f23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga181c7012ef5dd3a551a4e861c9fc974a" id="r_ga181c7012ef5dd3a551a4e861c9fc974a"><td class="memItemLeft" align="right" valign="top">static void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__comdlg.html#ga181c7012ef5dd3a551a4e861c9fc974a">fatal</a> )(const char *,...) = ::fatal</td></tr>
<tr class="memdesc:ga181c7012ef5dd3a551a4e861c9fc974a"><td class="mdescLeft">&#160;</td><td class="mdescRight">FLTK calls <a class="el" href="group__group__comdlg.html#ga181c7012ef5dd3a551a4e861c9fc974a" title="FLTK calls Fl::fatal() to output a fatal error message.">Fl::fatal()</a> to output a fatal error message.  <br /></td></tr>
<tr class="separator:ga181c7012ef5dd3a551a4e861c9fc974a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64d41edd7d962116d86a9db810210f7b" id="r_a64d41edd7d962116d86a9db810210f7b"><td class="memItemLeft" align="right" valign="top">static const char *const&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl.html#a64d41edd7d962116d86a9db810210f7b">help</a> = helpmsg+13</td></tr>
<tr class="memdesc:a64d41edd7d962116d86a9db810210f7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Usage string displayed if <a class="el" href="classFl.html#a115903daf3593748cdd36a5e78e74534" title="Parse command line switches using the cb argument handler.">Fl::args()</a> detects an invalid argument.  <br /></td></tr>
<tr class="separator:a64d41edd7d962116d86a9db810210f7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60fb2b446096dd4742511edb459653d3" id="r_a60fb2b446096dd4742511edb459653d3"><td class="memItemLeft" align="right" valign="top">static void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl.html#a60fb2b446096dd4742511edb459653d3">idle</a> )()</td></tr>
<tr class="memdesc:a60fb2b446096dd4742511edb459653d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">The currently executing idle callback function: DO NOT USE THIS DIRECTLY!  <br /></td></tr>
<tr class="separator:a60fb2b446096dd4742511edb459653d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadec4624fcfc09e75fdaf59c2553fe8a9" id="r_gadec4624fcfc09e75fdaf59c2553fe8a9"><td class="memItemLeft" align="right" valign="top">static void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__comdlg.html#gadec4624fcfc09e75fdaf59c2553fe8a9">warning</a> )(const char *,...) = ::warning</td></tr>
<tr class="memdesc:gadec4624fcfc09e75fdaf59c2553fe8a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">FLTK calls <a class="el" href="group__group__comdlg.html#gadec4624fcfc09e75fdaf59c2553fe8a9" title="FLTK calls Fl::warning() to output a warning message.">Fl::warning()</a> to output a warning message.  <br /></td></tr>
<tr class="separator:gadec4624fcfc09e75fdaf59c2553fe8a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The <a class="el" href="classFl.html" title="The Fl is the FLTK global (static) class containing state information and global methods for the curr...">Fl</a> is the FLTK global (static) class containing state information and global methods for the current application. </p>
</div><h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="a43e6e0bbbc03cad134d928d4edd48d1d" name="a43e6e0bbbc03cad134d928d4edd48d1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43e6e0bbbc03cad134d928d4edd48d1d">&#9670;&#160;</a></span>Fl_Option</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classFl.html#a43e6e0bbbc03cad134d928d4edd48d1d">Fl::Fl_Option</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enumerator for global FLTK options. </p>
<p>These options can be set system wide, per user, or for the running application only. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classFl.html#a9b040cad5d6fc04bb139877015091c16" title="Override an option while the application is running.">Fl::option(Fl_Option, bool)</a> </dd>
<dd>
<a class="el" href="classFl.html#abc49722be45fb56cad89c7c067eda5e3" title="FLTK library options management.">Fl::option(Fl_Option)</a> </dd></dl>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a43e6e0bbbc03cad134d928d4edd48d1da0d10867528510b82613c085e6240ebf6" name="a43e6e0bbbc03cad134d928d4edd48d1da0d10867528510b82613c085e6240ebf6"></a>OPTION_ARROW_FOCUS&#160;</td><td class="fielddoc"><p>When switched on, moving the text cursor beyond the start or end of a text in a text widget will change focus to the next text widget. </p>
<p>(This is considered 'old' behavior)</p>
<p>When switched off (default), the cursor will stop at the end of the text. Pressing Tab or Ctrl-Tab will advance the keyboard focus.</p>
<p>See also: <a class="el" href="classFl__Input__.html#ae23c19c0081ab427fc5ad53d4f503f8d" title="Sets whether the Tab key does focus navigation, or inserts tab characters into Fl_Multiline_Input.">Fl_Input_::tab_nav()</a> </p>
</td></tr>
<tr><td class="fieldname"><a id="a43e6e0bbbc03cad134d928d4edd48d1dade29f22fc8066222d99ea3ccebc5e655" name="a43e6e0bbbc03cad134d928d4edd48d1dade29f22fc8066222d99ea3ccebc5e655"></a>OPTION_VISIBLE_FOCUS&#160;</td><td class="fielddoc"><p>If visible focus is switched on (default), FLTK will draw a dotted rectangle inside the widget that will receive the next keystroke. </p>
<p>If switched off, no such indicator will be drawn and keyboard navigation is disabled. </p>
</td></tr>
<tr><td class="fieldname"><a id="a43e6e0bbbc03cad134d928d4edd48d1da2344bf14f80ecf5971e8aa4493a3858a" name="a43e6e0bbbc03cad134d928d4edd48d1da2344bf14f80ecf5971e8aa4493a3858a"></a>OPTION_DND_TEXT&#160;</td><td class="fielddoc"><p>If text drag-and-drop is enabled (default), the user can select and drag text from any text widget. </p>
<p>If disabled, no dragging is possible, however dropping text from other applications still works. </p>
</td></tr>
<tr><td class="fieldname"><a id="a43e6e0bbbc03cad134d928d4edd48d1dae8214e42f77fe157297d61fdb818be2f" name="a43e6e0bbbc03cad134d928d4edd48d1dae8214e42f77fe157297d61fdb818be2f"></a>OPTION_SHOW_TOOLTIPS&#160;</td><td class="fielddoc"><p>If tooltips are enabled (default), hovering the mouse over a widget with a tooltip text will open a little tooltip window until the mouse leaves the widget. </p>
<p>If disabled, no tooltip is shown. </p>
</td></tr>
<tr><td class="fieldname"><a id="a43e6e0bbbc03cad134d928d4edd48d1da01d530d6bc747eb0c192038eb802a8bd" name="a43e6e0bbbc03cad134d928d4edd48d1da01d530d6bc747eb0c192038eb802a8bd"></a>OPTION_FNFC_USES_GTK&#160;</td><td class="fielddoc"><p>When switched on (default), <a class="el" href="classFl__Native__File__Chooser.html" title="This class lets an FLTK application easily and consistently access the operating system&#39;s native file...">Fl_Native_File_Chooser</a> runs GTK file dialogs if the GTK library is available on the platform (linux/unix only). </p>
<p>When switched off, GTK file dialogs aren't used even if the GTK library is available. </p>
</td></tr>
<tr><td class="fieldname"><a id="a43e6e0bbbc03cad134d928d4edd48d1da220ebf62255fc47e5b5f213b410e2bc5" name="a43e6e0bbbc03cad134d928d4edd48d1da220ebf62255fc47e5b5f213b410e2bc5"></a>OPTION_LAST&#160;</td><td class="fielddoc"><p>For internal use only. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="aeec1fc58b2ded93866e75fc0f317b284" name="aeec1fc58b2ded93866e75fc0f317b284"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeec1fc58b2ded93866e75fc0f317b284">&#9670;&#160;</a></span>abi_check()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int Fl::abi_check </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>val</em> = <code><a class="el" href="Enumerations_8H.html#a619cd27e13a15a7b1b5ead0932dd3912">FL_ABI_VERSION</a></code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether the runtime library ABI version is correct. </p>
<p>This enables you to check the ABI version of the linked FLTK library at runtime.</p>
<p>Returns 1 (true) if the compiled ABI version (in the header files) and the linked library ABI version (used at runtime) are the same, 0 (false) otherwise.</p>
<p>Argument <code>val</code> can be used to query a particular library ABI version. Use for instance 10303 to query if the runtime library is compatible with FLTK ABI version 1.3.3. This is rarely useful.</p>
<p>The default <code>val</code> argument is FL_ABI_VERSION, which checks the version defined at configure time (i.e. in the header files at program compilation time) against the linked library version used at runtime. This is particularly useful if you linked with a shared object library, but it also concerns static linking.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classFl.html#aaa664880d0a1fab25b7bb53803112093" title="Returns the compiled-in value of the FL_ABI_VERSION constant.">Fl::abi_version()</a> </dd></dl>

</div>
</div>
<a id="aaa664880d0a1fab25b7bb53803112093" name="aaa664880d0a1fab25b7bb53803112093"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa664880d0a1fab25b7bb53803112093">&#9670;&#160;</a></span>abi_version()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Fl::abi_version </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the compiled-in value of the FL_ABI_VERSION constant. </p>
<p>This is useful for checking the version of a shared library. </p>

</div>
</div>
<a id="a7b689a9e42582fe6e87f7c7eb1dce94f" name="a7b689a9e42582fe6e87f7c7eb1dce94f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b689a9e42582fe6e87f7c7eb1dce94f">&#9670;&#160;</a></span>add_check()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Fl::add_check </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__callback__functions.html#ga17b5c6570394124287997166a50ff07a">Fl_Timeout_Handler</a>&#160;</td>
          <td class="paramname"><em>cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>argp</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>FLTK will call this callback just before it flushes the display and waits for events. </p>
<p>This is different than an idle callback because it is only called once, then FLTK calls the system and tells it not to return until an event happens.</p>
<p>This can be used by code that wants to monitor the application's state, such as to keep a display up to date. The advantage of using a check callback is that it is called only when no events are pending. If events are coming in quickly, whole blocks of them will be processed before this is called once. This can save significant time and avoid the application falling behind the events.</p>
<p>Sample code:</p>
<div class="fragment"><div class="line"><span class="keywordtype">bool</span> state_changed; <span class="comment">// anything that changes the display turns this on</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> callback(<span class="keywordtype">void</span>*) {</div>
<div class="line"> <span class="keywordflow">if</span> (!state_changed) <span class="keywordflow">return</span>;</div>
<div class="line"> state_changed = <span class="keyword">false</span>;</div>
<div class="line"> do_expensive_calculation();</div>
<div class="line"> widget-&amp;gt;<a class="code hl_function" href="classFl.html#aeec5e7939d214882da2d31c894a5bad7">redraw</a>();</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">main() {</div>
<div class="line"> <a class="code hl_function" href="classFl.html#a7b689a9e42582fe6e87f7c7eb1dce94f">Fl::add_check</a>(callback);</div>
<div class="line"> <span class="keywordflow">return</span> <a class="code hl_function" href="classFl.html#a7a3b1236b41800d24267288c564b187a">Fl::run</a>();</div>
<div class="line">}</div>
<div class="ttc" id="aclassFl_html_a7a3b1236b41800d24267288c564b187a"><div class="ttname"><a href="classFl.html#a7a3b1236b41800d24267288c564b187a">Fl::run</a></div><div class="ttdeci">static int run()</div><div class="ttdoc">As long as any windows are displayed this calls Fl::wait() repeatedly.</div><div class="ttdef"><b>Definition</b> Fl.cxx:641</div></div>
<div class="ttc" id="aclassFl_html_a7b689a9e42582fe6e87f7c7eb1dce94f"><div class="ttname"><a href="classFl.html#a7b689a9e42582fe6e87f7c7eb1dce94f">Fl::add_check</a></div><div class="ttdeci">static void add_check(Fl_Timeout_Handler, void *=0)</div><div class="ttdoc">FLTK will call this callback just before it flushes the display and waits for events.</div><div class="ttdef"><b>Definition</b> Fl.cxx:429</div></div>
<div class="ttc" id="aclassFl_html_aeec5e7939d214882da2d31c894a5bad7"><div class="ttname"><a href="classFl.html#aeec5e7939d214882da2d31c894a5bad7">Fl::redraw</a></div><div class="ttdeci">static void redraw()</div><div class="ttdoc">Redraws all widgets.</div><div class="ttdef"><b>Definition</b> Fl.cxx:786</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a799b8278326b3c2db15687c43c11aaf6" name="a799b8278326b3c2db15687c43c11aaf6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a799b8278326b3c2db15687c43c11aaf6">&#9670;&#160;</a></span>add_fd()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void Fl::add_fd </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>when</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__callback__functions.html#ga2cff1a51089da7653ab49bae499dfbf4">Fl_FD_Handler</a>&#160;</td>
          <td class="paramname"><em>cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds file descriptor fd to listen to. </p>
<p>When the fd becomes ready for reading <a class="el" href="classFl.html#a108a84216f0b3fa1cb0c46ab7449a312" title="Waits until &quot;something happens&quot; and then returns.">Fl::wait()</a> will call the callback and then return. The callback is passed the fd and the arbitrary void* argument.</p>
<p>The second version takes a when bitfield, with the bits FL_READ, FL_WRITE, and FL_EXCEPT defined, to indicate when the callback should be done.</p>
<p>There can only be one callback of each type for a file descriptor. <a class="el" href="classFl.html#a1c7766bf3e45e170fe1741e98092e55f" title="Removes a file descriptor handler.">Fl::remove_fd()</a> gets rid of <em>all</em> the callbacks for a given file descriptor.</p>
<p>Under UNIX <em>any</em> file descriptor can be monitored (files, devices, pipes, sockets, etc.). Due to limitations in Microsoft Windows, WIN32 applications can only monitor sockets. </p>

</div>
</div>
<a id="a4e7a1b5d18c2f073238a8466a62a3e7a" name="a4e7a1b5d18c2f073238a8466a62a3e7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e7a1b5d18c2f073238a8466a62a3e7a">&#9670;&#160;</a></span>add_idle()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Fl::add_idle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__callback__functions.html#gac9d2aab1d3142308450e2da09716013e">Fl_Idle_Handler</a>&#160;</td>
          <td class="paramname"><em>cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds a callback function that is called every time by <a class="el" href="classFl.html#a108a84216f0b3fa1cb0c46ab7449a312" title="Waits until &quot;something happens&quot; and then returns.">Fl::wait()</a> and also makes it act as though the timeout is zero (this makes <a class="el" href="classFl.html#a108a84216f0b3fa1cb0c46ab7449a312" title="Waits until &quot;something happens&quot; and then returns.">Fl::wait()</a> return immediately, so if it is in a loop it is called repeatedly, and thus the idle fucntion is called repeatedly). </p>
<p>The idle function can be used to get background processing done.</p>
<p>You can have multiple idle callbacks. To remove an idle callback use <a class="el" href="classFl.html#a43903f998a07e1cca7ba199c8ed25d9b" title="Removes the specified idle callback, if it is installed.">Fl::remove_idle()</a>.</p>
<p><a class="el" href="classFl.html#a108a84216f0b3fa1cb0c46ab7449a312" title="Waits until &quot;something happens&quot; and then returns.">Fl::wait()</a> and <a class="el" href="classFl.html#a1dbb83f1d52001c152ccf8415e3ee6f0" title="Same as Fl::wait(0).">Fl::check()</a> call idle callbacks, but <a class="el" href="classFl.html#a41a0cf2dd925cc6c4074d32a36fcf98f" title="This is similar to Fl::check() except this does not call Fl::flush() or any callbacks,...">Fl::ready()</a> does not.</p>
<p>The idle callback can call any FLTK functions, including <a class="el" href="classFl.html#a108a84216f0b3fa1cb0c46ab7449a312" title="Waits until &quot;something happens&quot; and then returns.">Fl::wait()</a>, <a class="el" href="classFl.html#a1dbb83f1d52001c152ccf8415e3ee6f0" title="Same as Fl::wait(0).">Fl::check()</a>, and <a class="el" href="classFl.html#a41a0cf2dd925cc6c4074d32a36fcf98f" title="This is similar to Fl::check() except this does not call Fl::flush() or any callbacks,...">Fl::ready()</a>.</p>
<p>FLTK will not recursively call the idle callback. </p>

</div>
</div>
<a id="a23e63eb7cec3a27fa360e66c6e2b2e52" name="a23e63eb7cec3a27fa360e66c6e2b2e52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23e63eb7cec3a27fa360e66c6e2b2e52">&#9670;&#160;</a></span>add_timeout()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Fl::add_timeout </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__callback__functions.html#ga17b5c6570394124287997166a50ff07a">Fl_Timeout_Handler</a>&#160;</td>
          <td class="paramname"><em>cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>argp</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds a one-shot timeout callback. </p>
<p>The function will be called by <a class="el" href="classFl.html#a108a84216f0b3fa1cb0c46ab7449a312" title="Waits until &quot;something happens&quot; and then returns.">Fl::wait()</a> at <em>t</em> seconds after this function is called. The optional void* argument is passed to the callback.</p>
<p>You can have multiple timeout callbacks. To remove a timeout callback use <a class="el" href="classFl.html#a9a950f0585de6416eb4fee2365a1578f" title="Removes a timeout callback.">Fl::remove_timeout()</a>.</p>
<p>If you need more accurate, repeated timeouts, use <a class="el" href="classFl.html#ae5373d1d50c2b0ba38280d78bb6d2628" title="Repeats a timeout callback from the expiration of the previous timeout, allowing for more accurate ti...">Fl::repeat_timeout()</a> to reschedule the subsequent timeouts.</p>
<p>The following code will print "TICK" each second on stdout with a fair degree of accuracy:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;stdio.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="Fl_8H.html">FL/Fl.H</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="Fl__Window_8H.html">FL/Fl_Window.H</a>&gt;</span></div>
<div class="line"><span class="keywordtype">void</span> callback(<span class="keywordtype">void</span>*) {</div>
<div class="line">  printf(<span class="stringliteral">&quot;TICK\n&quot;</span>);</div>
<div class="line">  <a class="code hl_function" href="classFl.html#ae5373d1d50c2b0ba38280d78bb6d2628">Fl::repeat_timeout</a>(1.0, callback);    <span class="comment">// retrigger timeout</span></div>
<div class="line">}</div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">  <a class="code hl_class" href="classFl__Window.html">Fl_Window</a> win(100,100);</div>
<div class="line">  win.show();</div>
<div class="line">  <a class="code hl_function" href="classFl.html#a23e63eb7cec3a27fa360e66c6e2b2e52">Fl::add_timeout</a>(1.0, callback);       <span class="comment">// set up first timeout</span></div>
<div class="line">  <span class="keywordflow">return</span> <a class="code hl_function" href="classFl.html#a7a3b1236b41800d24267288c564b187a">Fl::run</a>();</div>
<div class="line">}</div>
<div class="ttc" id="aFl_8H_html"><div class="ttname"><a href="Fl_8H.html">Fl.H</a></div><div class="ttdoc">Fl static class.</div></div>
<div class="ttc" id="aFl__Window_8H_html"><div class="ttname"><a href="Fl__Window_8H.html">Fl_Window.H</a></div><div class="ttdoc">Fl_Window widget .</div></div>
<div class="ttc" id="aclassFl__Window_html"><div class="ttname"><a href="classFl__Window.html">Fl_Window</a></div><div class="ttdoc">This widget produces an actual window.</div><div class="ttdef"><b>Definition</b> Fl_Window.H:57</div></div>
<div class="ttc" id="aclassFl_html_a23e63eb7cec3a27fa360e66c6e2b2e52"><div class="ttname"><a href="classFl.html#a23e63eb7cec3a27fa360e66c6e2b2e52">Fl::add_timeout</a></div><div class="ttdeci">static void add_timeout(double t, Fl_Timeout_Handler, void *=0)</div><div class="ttdoc">Adds a one-shot timeout callback.</div><div class="ttdef"><b>Definition</b> Fl.cxx:329</div></div>
<div class="ttc" id="aclassFl_html_ae5373d1d50c2b0ba38280d78bb6d2628"><div class="ttname"><a href="classFl.html#ae5373d1d50c2b0ba38280d78bb6d2628">Fl::repeat_timeout</a></div><div class="ttdeci">static void repeat_timeout(double t, Fl_Timeout_Handler, void *=0)</div><div class="ttdoc">Repeats a timeout callback from the expiration of the previous timeout, allowing for more accurate ti...</div><div class="ttdef"><b>Definition</b> Fl.cxx:334</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a7600b0ef3dcd4311850ab4b2988d5d6d" name="a7600b0ef3dcd4311850ab4b2988d5d6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7600b0ef3dcd4311850ab4b2988d5d6d">&#9670;&#160;</a></span>api_version()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Fl::api_version </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the compiled-in value of the FL_API_VERSION constant. </p>
<p>This is useful for checking the version of a shared library. </p>

</div>
</div>
<a id="a1576b8c9ca3e900daaa5c36ca0e7ae48" name="a1576b8c9ca3e900daaa5c36ca0e7ae48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1576b8c9ca3e900daaa5c36ca0e7ae48">&#9670;&#160;</a></span>arg()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Fl::arg </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>argc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>argv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Parse a single switch from <code>argv</code>, starting at word <code>i</code>. </p>
<p>Returns the number of words eaten (1 or 2, or 0 if it is not recognized) and adds the same value to <code>i</code>.</p>
<p>This is the default argument handler used internally by Fl::args(...), but you can use this function if you prefer to step through the standard FLTK switches yourself.</p>
<p>All standard FLTK switches except -bg2 may be abbreviated to just one letter and case is ignored:</p>
<ul>
<li>-bg color or -background color <br  />
 Sets the background color using <a class="el" href="classFl.html#a422da0dfc6aa51721e7c9a6ccf5b90ef" title="Changes fl_color(FL_BACKGROUND_COLOR) to the given color, and changes the gray ramp from 32 to 56 to ...">Fl::background()</a>.</li>
</ul>
<ul>
<li>-bg2 color or -background2 color <br  />
 Sets the secondary background color using <a class="el" href="classFl.html#a98d4c4557a2127bfc46abe15feed3be2" title="Changes the alternative background color.">Fl::background2()</a>.</li>
</ul>
<ul>
<li>-display host:n.n <br  />
 Sets the X display to use; this option is silently ignored under WIN32 and MacOS.</li>
</ul>
<ul>
<li>-dnd and -nodnd <br  />
 Enables or disables drag and drop text operations using <a class="el" href="classFl.html#aae157def51e4dabe5f75298b676ddea2" title="Gets or sets whether drag and drop text operations are supported.">Fl::dnd_text_ops()</a>.</li>
</ul>
<ul>
<li>-fg color or -foreground color <br  />
 Sets the foreground color using <a class="el" href="classFl.html#afbf02f998cce7ebb3331def57fccc8a7" title="Changes fl_color(FL_FOREGROUND_COLOR).">Fl::foreground()</a>.</li>
</ul>
<ul>
<li>-geometry WxH+X+Y <br  />
 Sets the initial window position and size according to the standard X geometry string.</li>
</ul>
<ul>
<li>-iconic <br  />
 Iconifies the window using <a class="el" href="classFl__Window.html#a473a9728b4275ce16347e74faafb3cde" title="Iconifies the window.">Fl_Window::iconize()</a>.</li>
</ul>
<ul>
<li>-kbd and -nokbd <br  />
 Enables or disables visible keyboard focus for non-text widgets using <a class="el" href="classFl.html#ae9eaddd02a0aa637078ee2dd80b85b2f" title="Gets or sets the visible keyboard focus on buttons and other non-text widgets.">Fl::visible_focus()</a>.</li>
</ul>
<ul>
<li>-name string <br  />
 Sets the window class using <a class="el" href="classFl__Window.html#a5f4838ae3f1100495d1f4eeca6c33397" title="Returns the xclass for this window, or a default.">Fl_Window::xclass()</a>.</li>
</ul>
<ul>
<li>-scheme string <br  />
 Sets the widget scheme using <a class="el" href="classFl.html#a1fb645ed69b6be60ff971b58a20853ec" title="See void scheme(const char *name)">Fl::scheme()</a>.</li>
</ul>
<ul>
<li>-title string <br  />
 Sets the window title using <a class="el" href="classFl__Window.html#af1f888ffe77b4ad40ef031ceb1add32c" title="See void Fl_Window::label(const char*)">Fl_Window::label()</a>.</li>
</ul>
<ul>
<li>-tooltips and -notooltips <br  />
 Enables or disables tooltips using <a class="el" href="classFl__Tooltip.html#aad7ec1340800ab9d883a035118f20995" title="Enables tooltips on all widgets (or disables if b is false).">Fl_Tooltip::enable()</a>.</li>
</ul>
<p>If your program requires other switches in addition to the standard FLTK options, you will need to pass your own argument handler to <a class="el" href="classFl.html#a115903daf3593748cdd36a5e78e74534" title="Parse command line switches using the cb argument handler.">Fl::args(int,char**,int&amp;,Fl_Args_Handler)</a> explicitly. </p>

</div>
</div>
<a id="a6fb24179ad2642412f4042863fe23645" name="a6fb24179ad2642412f4042863fe23645"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6fb24179ad2642412f4042863fe23645">&#9670;&#160;</a></span>args() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Fl::args </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>argc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>argv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Parse all command line switches matching standard FLTK options only. </p>
<p>It parses all the switches, and if any are not recognized it calls Fl::abort(Fl::help), i.e. unlike the long form, an unrecognized switch generates an error message and causes the program to exit. </p>

</div>
</div>
<a id="a115903daf3593748cdd36a5e78e74534" name="a115903daf3593748cdd36a5e78e74534"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a115903daf3593748cdd36a5e78e74534">&#9670;&#160;</a></span>args() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Fl::args </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>argc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>argv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__callback__functions.html#ga6cb5354ccaa2a6619f2408dbb5203f3b">Fl_Args_Handler</a>&#160;</td>
          <td class="paramname"><em>cb</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Parse command line switches using the <code>cb</code> argument handler. </p>
<p>Returns 0 on error, or the number of words processed.</p>
<p>FLTK provides this as an <em>entirely optional</em> command line switch parser. You don't have to call it if you don't want to. Everything it can do can be done with other calls to FLTK.</p>
<p>To use the switch parser, call Fl::args(...) near the start of your program. This does <b>not</b> open the display, instead switches that need the display open are stashed into static variables. Then you <b>must</b> display your first window by calling <code>window-&gt;show(argc,argv)</code>, which will do anything stored in the static variables.</p>
<p>Providing an argument handler callback <code>cb</code> lets you define your own switches. It is called with the same <code>argc</code> and <code>argv</code>, and with <code>i</code> set to the index of the switch to be processed. The <code>cb</code> handler should return zero if the switch is unrecognized, and not change <code>i</code>. It should return non-zero to indicate the number of words processed if the switch is recognized, i.e. 1 for just the switch, and more than 1 for the switch plus associated parameters. <code>i</code> should be incremented by the same amount.</p>
<p>The <code>cb</code> handler is called <b>before</b> any other tests, so <em>you can also override any standard FLTK switch</em> (this is why FLTK can use very short switches instead of the long ones all other toolkits force you to use). See <a class="el" href="classFl.html#a1576b8c9ca3e900daaa5c36ca0e7ae48" title="Parse a single switch from argv, starting at word i.">Fl::arg()</a> for descriptions of the standard switches.</p>
<p>On return <code>i</code> is set to the index of the first non-switch. This is either:</p>
<ul>
<li>The first word that does not start with '-'. </li>
<li>The word '-' (used by many programs to name stdin as a file) </li>
<li>The first unrecognized switch (return value is 0). </li>
<li><code>argc</code> </li>
</ul>
<p>The return value is <code>i</code> unless an unrecognized switch is found, in which case it is zero. If your program takes no arguments other than switches you should produce an error if the return value is less than <code>argc</code>.</p>
<p>A usage string is displayed if <a class="el" href="classFl.html#a115903daf3593748cdd36a5e78e74534" title="Parse command line switches using the cb argument handler.">Fl::args()</a> detects an invalid argument on the command-line. You can change the message by setting the <a class="el" href="classFl.html#a64d41edd7d962116d86a9db810210f7b" title="Usage string displayed if Fl::args() detects an invalid argument.">Fl::help</a> pointer.</p>
<p>A very simple command line parser can be found in <code>examples/howto-parse-args.cxx</code></p>
<p>The simpler <a class="el" href="classFl.html#a6fb24179ad2642412f4042863fe23645" title="Parse all command line switches matching standard FLTK options only.">Fl::args(int argc, char **argv)</a> form is useful if your program does not have command line switches of its own. </p>

</div>
</div>
<a id="a422da0dfc6aa51721e7c9a6ccf5b90ef" name="a422da0dfc6aa51721e7c9a6ccf5b90ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a422da0dfc6aa51721e7c9a6ccf5b90ef">&#9670;&#160;</a></span>background()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Fl::background </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="fl__types_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a>&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="fl__types_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a>&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="fl__types_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Changes fl_color(FL_BACKGROUND_COLOR) to the given color, and changes the gray ramp from 32 to 56 to black to white. </p>
<p>These are the colors used as backgrounds by almost all widgets and used to draw the edges of all the boxtypes. </p>

</div>
</div>
<a id="a98d4c4557a2127bfc46abe15feed3be2" name="a98d4c4557a2127bfc46abe15feed3be2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98d4c4557a2127bfc46abe15feed3be2">&#9670;&#160;</a></span>background2()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Fl::background2 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="fl__types_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a>&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="fl__types_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a>&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="fl__types_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Changes the alternative background color. </p>
<p>This color is used as a background by <a class="el" href="classFl__Input.html" title="This is the FLTK text input widget.">Fl_Input</a> and other text widgets. </p>
<p>This call may change fl_color(FL_FOREGROUND_COLOR) if it does not provide sufficient contrast to FL_BACKGROUND2_COLOR. </p>

</div>
</div>
<a id="aaaecb51f270a5b42ad31f0e8091635dd" name="aaaecb51f270a5b42ad31f0e8091635dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaaecb51f270a5b42ad31f0e8091635dd">&#9670;&#160;</a></span>box_color()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Enumerations_8H.html#a8b762953646f8abee866061f1af78a6a">Fl_Color</a> Fl::box_color </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="Enumerations_8H.html#a8b762953646f8abee866061f1af78a6a">Fl_Color</a>&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the drawing color to be used for the background of a box. </p>
<p>This method is only useful inside box drawing code. It returns the color to be used, either fl_inactive(c) if the widget is inactive_r() or <code>c</code> otherwise. </p>

</div>
</div>
<a id="af739a06d44dc94d09015ed1940b9f066" name="af739a06d44dc94d09015ed1940b9f066"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af739a06d44dc94d09015ed1940b9f066">&#9670;&#160;</a></span>box_dh()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Fl::box_dh </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="Enumerations_8H.html#ae48bf9070f8541de17829f54ccacc6bc">Fl_Boxtype</a>&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the height offset for the given boxtype. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classFl.html#a9fbd0a2a5c43a30893dec05e8d34dc15" title="Returns the Y offset for the given boxtype.">box_dy()</a>. </dd></dl>

</div>
</div>
<a id="a9a327ed95a8c2533ca4eee659bf3d557" name="a9a327ed95a8c2533ca4eee659bf3d557"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a327ed95a8c2533ca4eee659bf3d557">&#9670;&#160;</a></span>box_dw()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Fl::box_dw </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="Enumerations_8H.html#ae48bf9070f8541de17829f54ccacc6bc">Fl_Boxtype</a>&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the width offset for the given boxtype. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classFl.html#a9fbd0a2a5c43a30893dec05e8d34dc15" title="Returns the Y offset for the given boxtype.">box_dy()</a>. </dd></dl>

</div>
</div>
<a id="a2971f20fe3595fd8f77fe73d4eb89594" name="a2971f20fe3595fd8f77fe73d4eb89594"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2971f20fe3595fd8f77fe73d4eb89594">&#9670;&#160;</a></span>box_dx()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Fl::box_dx </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="Enumerations_8H.html#ae48bf9070f8541de17829f54ccacc6bc">Fl_Boxtype</a>&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the X offset for the given boxtype. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classFl.html#a9fbd0a2a5c43a30893dec05e8d34dc15" title="Returns the Y offset for the given boxtype.">box_dy()</a> </dd></dl>

</div>
</div>
<a id="a9fbd0a2a5c43a30893dec05e8d34dc15" name="a9fbd0a2a5c43a30893dec05e8d34dc15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9fbd0a2a5c43a30893dec05e8d34dc15">&#9670;&#160;</a></span>box_dy()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Fl::box_dy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="Enumerations_8H.html#ae48bf9070f8541de17829f54ccacc6bc">Fl_Boxtype</a>&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the Y offset for the given boxtype. </p>
<p>These functions return the offset values necessary for a given boxtype, useful for computing the area inside a box's borders, to prevent overdrawing the borders.</p>
<p>For instance, in the case of a boxtype like FL_DOWN_BOX where the border width might be 2 pixels all around, the above functions would return 2, 2, 4, and 4 for box_dx, box_dy, box_dw, and box_dh respectively.</p>
<p>An example to compute the area inside a widget's box(): </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> X = yourwidget-&gt;x() + <a class="code hl_function" href="classFl.html#a2971f20fe3595fd8f77fe73d4eb89594">Fl::box_dx</a>(yourwidget-&gt;box());</div>
<div class="line"><span class="keywordtype">int</span> Y = yourwidget-&gt;y() + <a class="code hl_function" href="classFl.html#a9fbd0a2a5c43a30893dec05e8d34dc15">Fl::box_dy</a>(yourwidget-&gt;box());</div>
<div class="line"><span class="keywordtype">int</span> W = yourwidget-&gt;w() - <a class="code hl_function" href="classFl.html#a9a327ed95a8c2533ca4eee659bf3d557">Fl::box_dw</a>(yourwidget-&gt;box());</div>
<div class="line"><span class="keywordtype">int</span> H = yourwidget-&gt;h() - <a class="code hl_function" href="classFl.html#af739a06d44dc94d09015ed1940b9f066">Fl::box_dh</a>(yourwidget-&gt;box());</div>
<div class="ttc" id="aclassFl_html_a2971f20fe3595fd8f77fe73d4eb89594"><div class="ttname"><a href="classFl.html#a2971f20fe3595fd8f77fe73d4eb89594">Fl::box_dx</a></div><div class="ttdeci">static int box_dx(Fl_Boxtype)</div><div class="ttdoc">Returns the X offset for the given boxtype.</div><div class="ttdef"><b>Definition</b> fl_boxtype.cxx:360</div></div>
<div class="ttc" id="aclassFl_html_a9a327ed95a8c2533ca4eee659bf3d557"><div class="ttname"><a href="classFl.html#a9a327ed95a8c2533ca4eee659bf3d557">Fl::box_dw</a></div><div class="ttdeci">static int box_dw(Fl_Boxtype)</div><div class="ttdoc">Returns the width offset for the given boxtype.</div><div class="ttdef"><b>Definition</b> fl_boxtype.cxx:391</div></div>
<div class="ttc" id="aclassFl_html_a9fbd0a2a5c43a30893dec05e8d34dc15"><div class="ttname"><a href="classFl.html#a9fbd0a2a5c43a30893dec05e8d34dc15">Fl::box_dy</a></div><div class="ttdeci">static int box_dy(Fl_Boxtype)</div><div class="ttdoc">Returns the Y offset for the given boxtype.</div><div class="ttdef"><b>Definition</b> fl_boxtype.cxx:385</div></div>
<div class="ttc" id="aclassFl_html_af739a06d44dc94d09015ed1940b9f066"><div class="ttname"><a href="classFl.html#af739a06d44dc94d09015ed1940b9f066">Fl::box_dh</a></div><div class="ttdeci">static int box_dh(Fl_Boxtype)</div><div class="ttdoc">Returns the height offset for the given boxtype.</div><div class="ttdef"><b>Definition</b> fl_boxtype.cxx:397</div></div>
</div><!-- fragment --><p> These functions are mainly useful in the draw() code for deriving custom widgets, where one wants to avoid drawing over the widget's own border box(). </p>

</div>
</div>
<a id="a1dbb83f1d52001c152ccf8415e3ee6f0" name="a1dbb83f1d52001c152ccf8415e3ee6f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1dbb83f1d52001c152ccf8415e3ee6f0">&#9670;&#160;</a></span>check()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Fl::check </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Same as Fl::wait(0). </p>
<p>Calling this during a big calculation will keep the screen up to date and the interface responsive:</p>
<div class="fragment"><div class="line"><span class="keywordflow">while</span> (!calculation_done()) {</div>
<div class="line">calculate();</div>
<div class="line"><a class="code hl_function" href="classFl.html#a1dbb83f1d52001c152ccf8415e3ee6f0">Fl::check</a>();</div>
<div class="line"><span class="keywordflow">if</span> (user_hit_abort_button()) <span class="keywordflow">break</span>;</div>
<div class="line">}</div>
<div class="ttc" id="aclassFl_html_a1dbb83f1d52001c152ccf8415e3ee6f0"><div class="ttname"><a href="classFl.html#a1dbb83f1d52001c152ccf8415e3ee6f0">Fl::check</a></div><div class="ttdeci">static int check()</div><div class="ttdoc">Same as Fl::wait(0).</div><div class="ttdef"><b>Definition</b> Fl.cxx:692</div></div>
</div><!-- fragment --><p>This returns non-zero if any windows are displayed, and 0 if no windows are displayed (this is likely to change in future versions of FLTK). </p>

</div>
</div>
<a id="a7c6847e1b7dd9628821656933ca8e79d" name="a7c6847e1b7dd9628821656933ca8e79d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c6847e1b7dd9628821656933ca8e79d">&#9670;&#160;</a></span>display()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Fl::display </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>d</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the X display to use for all windows. </p>
<p>Actually this just sets the environment variable $DISPLAY to the passed string, so this only works before you show() the first window or otherwise open the display, and does nothing useful under WIN32. </p>

</div>
</div>
<a id="aae157def51e4dabe5f75298b676ddea2" name="aae157def51e4dabe5f75298b676ddea2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae157def51e4dabe5f75298b676ddea2">&#9670;&#160;</a></span>dnd_text_ops() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int Fl::dnd_text_ops </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets or sets whether drag and drop text operations are supported. </p>
<p>This specifically affects whether selected text can be dragged from text fields or dragged within a text field as a cut/paste shortcut. </p>

</div>
</div>
<a id="a53430e25b53f3b608193fa4009898463" name="a53430e25b53f3b608193fa4009898463"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53430e25b53f3b608193fa4009898463">&#9670;&#160;</a></span>dnd_text_ops() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void Fl::dnd_text_ops </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets or sets whether drag and drop text operations are supported. </p>
<p>This specifically affects whether selected text can be dragged from text fields or dragged within a text field as a cut/paste shortcut. </p>

</div>
</div>
<a id="ad56cf568ee94318b50d2b2da0aa3031b" name="ad56cf568ee94318b50d2b2da0aa3031b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad56cf568ee94318b50d2b2da0aa3031b">&#9670;&#160;</a></span>draw_box_active()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Fl::draw_box_active </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if the currently drawn box is active or inactive. </p>
<p>If inactive, the box color should be changed to the inactive color.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classFl.html#aaaecb51f270a5b42ad31f0e8091635dd" title="Gets the drawing color to be used for the background of a box.">Fl::box_color(Fl_Color c)</a> </dd></dl>

</div>
</div>
<a id="a08d29d807ea3874b8bb16f7457f64bdc" name="a08d29d807ea3874b8bb16f7457f64bdc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08d29d807ea3874b8bb16f7457f64bdc">&#9670;&#160;</a></span>flush()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Fl::flush </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Causes all the windows that need it to be redrawn and graphics forced out through the pipes. </p>
<p>This is what <a class="el" href="classFl.html#a108a84216f0b3fa1cb0c46ab7449a312" title="Waits until &quot;something happens&quot; and then returns.">wait()</a> does before looking for events.</p>
<p>Note: in multi-threaded applications you should only call <a class="el" href="classFl.html#a08d29d807ea3874b8bb16f7457f64bdc" title="Causes all the windows that need it to be redrawn and graphics forced out through the pipes.">Fl::flush()</a> from the main thread. If a child thread needs to trigger a redraw event, it should instead call <a class="el" href="group__fl__multithread.html#gae9e8f440ce2ca05b047c620f75af13cb" title="Sends a message pointer to the main thread, causing any pending Fl::wait() call to terminate so that ...">Fl::awake()</a> to get the main thread to process the event queue. </p>

</div>
</div>
<a id="aed0a7958eebf1491685040be87490947" name="aed0a7958eebf1491685040be87490947"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed0a7958eebf1491685040be87490947">&#9670;&#160;</a></span>get_system_colors()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Fl::get_system_colors </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read the user preference colors from the system and use them to call <a class="el" href="classFl.html#afbf02f998cce7ebb3331def57fccc8a7" title="Changes fl_color(FL_FOREGROUND_COLOR).">Fl::foreground()</a>, <a class="el" href="classFl.html#a422da0dfc6aa51721e7c9a6ccf5b90ef" title="Changes fl_color(FL_BACKGROUND_COLOR) to the given color, and changes the gray ramp from 32 to 56 to ...">Fl::background()</a>, and <a class="el" href="classFl.html#a98d4c4557a2127bfc46abe15feed3be2" title="Changes the alternative background color.">Fl::background2()</a>. </p>
<p>This is done by Fl_Window::show(argc,argv) before applying the -fg and -bg switches.</p>
<p>On X this reads some common values from the Xdefaults database. KDE users can set these values by running the "krdb" program, and newer versions of KDE set this automatically if you check the "apply
style to other X programs" switch in their control panel. </p>

</div>
</div>
<a id="a3d21e87ef889306a7be56e94ea0bda10" name="a3d21e87ef889306a7be56e94ea0bda10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d21e87ef889306a7be56e94ea0bda10">&#9670;&#160;</a></span>gl_visual()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Fl::gl_visual </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>alist</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This does the same thing as <a class="el" href="classFl.html#a6d6deb3d4f76b538d508b36700dfb6b0" title="Selects a visual so that your graphics are drawn correctly.">Fl::visual(int)</a> but also requires OpenGL drawing to work. </p>
<p>This <em>must</em> be done if you want to draw in normal windows with OpenGL with <a class="el" href="gl_8h.html#a9c922d784b80b39b0e64c8f4cfb5d123" title="Creates an OpenGL context.">gl_start()</a> and gl_end(). It may be useful to call this so your X windows use the same visual as an <a class="el" href="classFl__Gl__Window.html" title="The Fl_Gl_Window widget sets things up so OpenGL works.">Fl_Gl_Window</a>, which on some servers will reduce colormap flashing.</p>
<p>See <a class="el" href="classFl__Gl__Window.html" title="The Fl_Gl_Window widget sets things up so OpenGL works.">Fl_Gl_Window</a> for a list of additional values for the argument. </p>

</div>
</div>
<a id="a19c26018ae654d07ec1aa73e35b244a4" name="a19c26018ae654d07ec1aa73e35b244a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19c26018ae654d07ec1aa73e35b244a4">&#9670;&#160;</a></span>is_scheme()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int Fl::is_scheme </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether the current scheme is the given name. </p>
<p>This is a fast inline convenience function to support scheme-specific code in widgets, e.g. in their draw() methods, if required.</p>
<p>Use a valid scheme name, not <code>NULL</code> (although <code>NULL</code> is allowed, this is not a useful argument - see below).</p>
<p>If <a class="el" href="classFl.html#a1fb645ed69b6be60ff971b58a20853ec" title="See void scheme(const char *name)">Fl::scheme()</a> has not been set or has been set to the default scheme ("none" or "base"), then this will always return 0 regardless of the argument, because <a class="el" href="classFl.html#a1fb645ed69b6be60ff971b58a20853ec" title="See void scheme(const char *name)">Fl::scheme()</a> is <code>NULL</code> in this case.</p>
<dl class="section note"><dt>Note</dt><dd>The stored scheme name is always lowercase, and this method will do a case-sensitive compare, so you <b>must</b> provide a lowercase string to return the correct value. This is intentional for performance reasons.</dd></dl>
<p>Example: </p><div class="fragment"><div class="line"><span class="keywordflow">if</span> (<a class="code hl_function" href="classFl.html#a19c26018ae654d07ec1aa73e35b244a4">Fl::is_scheme</a>(<span class="stringliteral">&quot;gtk+&quot;</span>)) { your_code_here(); }</div>
<div class="ttc" id="aclassFl_html_a19c26018ae654d07ec1aa73e35b244a4"><div class="ttname"><a href="classFl.html#a19c26018ae654d07ec1aa73e35b244a4">Fl::is_scheme</a></div><div class="ttdeci">static int is_scheme(const char *name)</div><div class="ttdoc">Returns whether the current scheme is the given name.</div><div class="ttdef"><b>Definition</b> Fl.H:375</div></div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td><b>lowercase</b> string of requested scheme name.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if the given scheme is active, 0 otherwise.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classFl.html#a9d070bb1d5a24c28beab53a70af095a4" title="Sets the current widget scheme.">Fl::scheme(const char *name)</a> </dd></dl>

</div>
</div>
<a id="abc49722be45fb56cad89c7c067eda5e3" name="abc49722be45fb56cad89c7c067eda5e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc49722be45fb56cad89c7c067eda5e3">&#9670;&#160;</a></span>option() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Fl::option </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classFl.html#a43e6e0bbbc03cad134d928d4edd48d1d">Fl_Option</a>&#160;</td>
          <td class="paramname"><em>opt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>FLTK library options management. </p>
<p>This function needs to be documented in more detail. It can be used for more optional settings, such as using a native file chooser instead of the FLTK one wherever possible, disabling tooltips, disabling visible focus, disabling FLTK file chooser preview, etc. .</p>
<p>There should be a command line option interface.</p>
<p>There should be an application that manages options system wide, per user, and per application.</p>
<p>Example: </p><div class="fragment"><div class="line"><span class="keywordflow">if</span> ( <a class="code hl_function" href="classFl.html#abc49722be45fb56cad89c7c067eda5e3">Fl::option</a>(<a class="code hl_enumvalue" href="classFl.html#a43e6e0bbbc03cad134d928d4edd48d1da0d10867528510b82613c085e6240ebf6">Fl::OPTION_ARROW_FOCUS</a>) )</div>
<div class="line">    { ..on..  }</div>
<div class="line"><span class="keywordflow">else</span></div>
<div class="line">    { ..off..  }</div>
<div class="ttc" id="aclassFl_html_a43e6e0bbbc03cad134d928d4edd48d1da0d10867528510b82613c085e6240ebf6"><div class="ttname"><a href="classFl.html#a43e6e0bbbc03cad134d928d4edd48d1da0d10867528510b82613c085e6240ebf6">Fl::OPTION_ARROW_FOCUS</a></div><div class="ttdeci">@ OPTION_ARROW_FOCUS</div><div class="ttdoc">When switched on, moving the text cursor beyond the start or end of a text in a text widget will chan...</div><div class="ttdef"><b>Definition</b> Fl.H:204</div></div>
<div class="ttc" id="aclassFl_html_abc49722be45fb56cad89c7c067eda5e3"><div class="ttname"><a href="classFl.html#abc49722be45fb56cad89c7c067eda5e3">Fl::option</a></div><div class="ttdeci">static bool option(Fl_Option opt)</div><div class="ttdoc">FLTK library options management.</div><div class="ttdef"><b>Definition</b> Fl.cxx:2186</div></div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>As of FLTK 1.3.0, options can be managed within fluid, using the menu <em>Edit/Global FLTK Settings</em>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">opt</td><td>which option </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true or false </dd></dl>
<dl class="section see"><dt>See also</dt><dd>enum <a class="el" href="classFl.html#a43e6e0bbbc03cad134d928d4edd48d1d" title="Enumerator for global FLTK options.">Fl::Fl_Option</a> </dd>
<dd>
<a class="el" href="classFl.html#a9b040cad5d6fc04bb139877015091c16" title="Override an option while the application is running.">Fl::option(Fl_Option, bool)</a></dd></dl>
<dl class="section since"><dt>Since</dt><dd>FLTK 1.3.0 </dd></dl>

</div>
</div>
<a id="a9b040cad5d6fc04bb139877015091c16" name="a9b040cad5d6fc04bb139877015091c16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b040cad5d6fc04bb139877015091c16">&#9670;&#160;</a></span>option() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Fl::option </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classFl.html#a43e6e0bbbc03cad134d928d4edd48d1d">Fl_Option</a>&#160;</td>
          <td class="paramname"><em>opt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Override an option while the application is running. </p>
<p>This function does not change any system or user settings.</p>
<p>Example: </p><div class="fragment"><div class="line"><a class="code hl_function" href="classFl.html#abc49722be45fb56cad89c7c067eda5e3">Fl::option</a>(<a class="code hl_enumvalue" href="classFl.html#a43e6e0bbbc03cad134d928d4edd48d1da0d10867528510b82613c085e6240ebf6">Fl::OPTION_ARROW_FOCUS</a>, <span class="keyword">true</span>);     <span class="comment">// on</span></div>
<div class="line"><a class="code hl_function" href="classFl.html#abc49722be45fb56cad89c7c067eda5e3">Fl::option</a>(<a class="code hl_enumvalue" href="classFl.html#a43e6e0bbbc03cad134d928d4edd48d1da0d10867528510b82613c085e6240ebf6">Fl::OPTION_ARROW_FOCUS</a>, <span class="keyword">false</span>);    <span class="comment">// off</span></div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">opt</td><td>which option </td></tr>
    <tr><td class="paramname">val</td><td>set to true or false </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>enum <a class="el" href="classFl.html#a43e6e0bbbc03cad134d928d4edd48d1d" title="Enumerator for global FLTK options.">Fl::Fl_Option</a> </dd>
<dd>
bool <a class="el" href="classFl.html#abc49722be45fb56cad89c7c067eda5e3" title="FLTK library options management.">Fl::option(Fl_Option)</a> </dd></dl>

</div>
</div>
<a id="a217dd709bed0d62a652625d505918fc6" name="a217dd709bed0d62a652625d505918fc6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a217dd709bed0d62a652625d505918fc6">&#9670;&#160;</a></span>own_colormap()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Fl::own_colormap </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Makes FLTK use its <a href="fltk-colormap.png">own colormap</a>. </p>
<p>This may make FLTK display better and will reduce conflicts with other programs that want lots of colors. However the colors may flash as you move the cursor between windows.</p>
<p>This does nothing if the current visual is not colormapped. </p>

</div>
</div>
<a id="a3c27ca2833030aa15482bd06dbfc5959" name="a3c27ca2833030aa15482bd06dbfc5959"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c27ca2833030aa15482bd06dbfc5959">&#9670;&#160;</a></span>readqueue()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classFl__Widget.html">Fl_Widget</a> * Fl::readqueue </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads the default callback queue and returns the first widget. </p>
<p>All Fl_Widgets that don't have a callback defined use the default callback <code>static</code> <a class="el" href="classFl__Widget.html#a21ee62080ef6da5c4970570cd6b7c141" title="The default callback for all widgets that don&#39;t set a callback.">Fl_Widget::default_callback()</a> that puts a pointer to the widget in a queue. This method reads the oldest widget out of this queue.</p>
<p>The queue (FIFO) is limited (currently 20 items). If the queue overflows, the oldest entry (<a class="el" href="classFl__Widget.html" title="Fl_Widget is the base class for all widgets in FLTK.">Fl_Widget</a> *) is discarded.</p>
<p>Relying on the default callback and reading the callback queue with <a class="el" href="classFl.html#a3c27ca2833030aa15482bd06dbfc5959" title="Reads the default callback queue and returns the first widget.">Fl::readqueue()</a> is not recommended. If you need a callback, you should set one with <a class="el" href="classFl__Widget.html#ad5fe4ff0d0f777af13f3d8818c869689" title="Sets the current callback function for the widget.">Fl_Widget::callback(Fl_Callback *cb, void *data)</a> or one of its variants.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classFl__Widget.html#ac32acdcfb3b722fccd2d3f946b01e799" title="Gets the current callback function for the widget.">Fl_Widget::callback()</a> </dd>
<dd>
<a class="el" href="classFl__Widget.html#ad5fe4ff0d0f777af13f3d8818c869689" title="Sets the current callback function for the widget.">Fl_Widget::callback(Fl_Callback *cb, void *data)</a> </dd>
<dd>
<a class="el" href="classFl__Widget.html#a21ee62080ef6da5c4970570cd6b7c141" title="The default callback for all widgets that don&#39;t set a callback.">Fl_Widget::default_callback()</a> </dd></dl>

</div>
</div>
<a id="a41a0cf2dd925cc6c4074d32a36fcf98f" name="a41a0cf2dd925cc6c4074d32a36fcf98f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41a0cf2dd925cc6c4074d32a36fcf98f">&#9670;&#160;</a></span>ready()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Fl::ready </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is similar to <a class="el" href="classFl.html#a1dbb83f1d52001c152ccf8415e3ee6f0" title="Same as Fl::wait(0).">Fl::check()</a> except this does <em>not</em> call <a class="el" href="classFl.html#a08d29d807ea3874b8bb16f7457f64bdc" title="Causes all the windows that need it to be redrawn and graphics forced out through the pipes.">Fl::flush()</a> or any callbacks, which is useful if your program is in a state where such callbacks are illegal. </p>
<p>This returns true if <a class="el" href="classFl.html#a1dbb83f1d52001c152ccf8415e3ee6f0" title="Same as Fl::wait(0).">Fl::check()</a> would do anything (it will continue to return true until you call <a class="el" href="classFl.html#a1dbb83f1d52001c152ccf8415e3ee6f0" title="Same as Fl::wait(0).">Fl::check()</a> or <a class="el" href="classFl.html#a108a84216f0b3fa1cb0c46ab7449a312" title="Waits until &quot;something happens&quot; and then returns.">Fl::wait()</a>).</p>
<div class="fragment"><div class="line"><span class="keywordflow">while</span> (!calculation_done()) {</div>
<div class="line">  calculate();</div>
<div class="line">  <span class="keywordflow">if</span> (<a class="code hl_function" href="classFl.html#a41a0cf2dd925cc6c4074d32a36fcf98f">Fl::ready</a>()) {</div>
<div class="line">    do_expensive_cleanup();</div>
<div class="line">    <a class="code hl_function" href="classFl.html#a1dbb83f1d52001c152ccf8415e3ee6f0">Fl::check</a>();</div>
<div class="line">    <span class="keywordflow">if</span> (user_hit_abort_button()) <span class="keywordflow">break</span>;</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="ttc" id="aclassFl_html_a41a0cf2dd925cc6c4074d32a36fcf98f"><div class="ttname"><a href="classFl.html#a41a0cf2dd925cc6c4074d32a36fcf98f">Fl::ready</a></div><div class="ttdeci">static int ready()</div><div class="ttdoc">This is similar to Fl::check() except this does not call Fl::flush() or any callbacks,...</div><div class="ttdef"><b>Definition</b> Fl.cxx:715</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a656023b0db49ae9b88e277ccdb27ce1b" name="a656023b0db49ae9b88e277ccdb27ce1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a656023b0db49ae9b88e277ccdb27ce1b">&#9670;&#160;</a></span>release()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void Fl::release </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Releases the current grabbed window, equals grab(0). </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000003">Deprecated:</a></b></dt><dd>Use Fl::grab(0) instead. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__fl__windows.html#ga0918f4dabb87b5e429ad4e0e38239845" title="Selects the window to grab.">grab(Fl_Window*)</a> </dd></dl>

</div>
</div>
<a id="a3cf6b5b7bfe06b268e8c51ec11acf378" name="a3cf6b5b7bfe06b268e8c51ec11acf378"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3cf6b5b7bfe06b268e8c51ec11acf378">&#9670;&#160;</a></span>reload_scheme()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Fl::reload_scheme </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Called by scheme according to scheme name. </p>
<p>Loads or reloads the current scheme selection. See void <a class="el" href="classFl.html#a9d070bb1d5a24c28beab53a70af095a4" title="Sets the current widget scheme.">scheme(const char *name)</a> </p>

</div>
</div>
<a id="a43ee3d6bb1c70f5202e7cc9cb87cd515" name="a43ee3d6bb1c70f5202e7cc9cb87cd515"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43ee3d6bb1c70f5202e7cc9cb87cd515">&#9670;&#160;</a></span>remove_check()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Fl::remove_check </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__callback__functions.html#ga17b5c6570394124287997166a50ff07a">Fl_Timeout_Handler</a>&#160;</td>
          <td class="paramname"><em>cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>argp</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes a check callback. </p>
<p>It is harmless to remove a check callback that no longer exists. </p>

</div>
</div>
<a id="a9a950f0585de6416eb4fee2365a1578f" name="a9a950f0585de6416eb4fee2365a1578f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a950f0585de6416eb4fee2365a1578f">&#9670;&#160;</a></span>remove_timeout()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Fl::remove_timeout </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__callback__functions.html#ga17b5c6570394124287997166a50ff07a">Fl_Timeout_Handler</a>&#160;</td>
          <td class="paramname"><em>cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>argp</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes a timeout callback. </p>
<p>It is harmless to remove a timeout callback that no longer exists.</p>
<dl class="section note"><dt>Note</dt><dd>This version removes all matching timeouts, not just the first one. This may change in the future. </dd></dl>

</div>
</div>
<a id="ae5373d1d50c2b0ba38280d78bb6d2628" name="ae5373d1d50c2b0ba38280d78bb6d2628"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5373d1d50c2b0ba38280d78bb6d2628">&#9670;&#160;</a></span>repeat_timeout()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Fl::repeat_timeout </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__callback__functions.html#ga17b5c6570394124287997166a50ff07a">Fl_Timeout_Handler</a>&#160;</td>
          <td class="paramname"><em>cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>argp</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Repeats a timeout callback from the expiration of the previous timeout, allowing for more accurate timing. </p>
<p>You may only call this method inside a timeout callback.</p>
<p>The following code will print "TICK" each second on stdout with a fair degree of accuracy:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> callback(<span class="keywordtype">void</span>*) {</div>
<div class="line">  puts(<span class="stringliteral">&quot;TICK&quot;</span>);</div>
<div class="line">  <a class="code hl_function" href="classFl.html#ae5373d1d50c2b0ba38280d78bb6d2628">Fl::repeat_timeout</a>(1.0, callback);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">  <a class="code hl_function" href="classFl.html#a23e63eb7cec3a27fa360e66c6e2b2e52">Fl::add_timeout</a>(1.0, callback);</div>
<div class="line">  <span class="keywordflow">return</span> <a class="code hl_function" href="classFl.html#a7a3b1236b41800d24267288c564b187a">Fl::run</a>();</div>
<div class="line">}</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a7a3b1236b41800d24267288c564b187a" name="a7a3b1236b41800d24267288c564b187a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a3b1236b41800d24267288c564b187a">&#9670;&#160;</a></span>run()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Fl::run </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>As long as any windows are displayed this calls <a class="el" href="classFl.html#a108a84216f0b3fa1cb0c46ab7449a312" title="Waits until &quot;something happens&quot; and then returns.">Fl::wait()</a> repeatedly. </p>
<p>When all the windows are closed it returns zero (supposedly it would return non-zero on any errors, but FLTK calls exit directly for these). A normal program will end main() with return <a class="el" href="classFl.html#a7a3b1236b41800d24267288c564b187a" title="As long as any windows are displayed this calls Fl::wait() repeatedly.">Fl::run()</a>;. </p>

</div>
</div>
<a id="a9d070bb1d5a24c28beab53a70af095a4" name="a9d070bb1d5a24c28beab53a70af095a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d070bb1d5a24c28beab53a70af095a4">&#9670;&#160;</a></span>scheme()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Fl::scheme </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the current widget scheme. </p>
<p>NULL will use the scheme defined in the FLTK_SCHEME environment variable or the scheme resource under X11. Otherwise, any of the following schemes can be used: </p><pre class="fragment">- "none" - This is the default look-n-feel which resembles old
           Windows (95/98/Me/NT/2000) and old GTK/KDE

- "base" - This is an alias for "none"

- "plastic" - This scheme is inspired by the Aqua user interface
              on Mac OS X

- "gtk+" - This scheme is inspired by the Red Hat Bluecurve theme

- "gleam" - This scheme is inspired by the Clearlooks Glossy scheme.
            (Colin Jones and Edmanuel Torres).
</pre><p> Uppercase scheme names are equivalent, but the stored scheme name will always be lowercase and <a class="el" href="classFl.html#a1fb645ed69b6be60ff971b58a20853ec" title="See void scheme(const char *name)">Fl::scheme()</a> will return this lowercase name.</p>
<p>If the resulting scheme name is not defined, the default scheme will be used and <a class="el" href="classFl.html#a1fb645ed69b6be60ff971b58a20853ec" title="See void scheme(const char *name)">Fl::scheme()</a> will return NULL.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classFl.html#a19c26018ae654d07ec1aa73e35b244a4" title="Returns whether the current scheme is the given name.">Fl::is_scheme()</a> </dd></dl>

</div>
</div>
<a id="a82c225037f05d07a7797da5eddafb33a" name="a82c225037f05d07a7797da5eddafb33a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82c225037f05d07a7797da5eddafb33a">&#9670;&#160;</a></span>scrollbar_size() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Fl::scrollbar_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the default scrollbar size used by <a class="el" href="classFl__Browser__.html" title="This is the base class for browsers.">Fl_Browser_</a>, <a class="el" href="classFl__Help__View.html" title="The Fl_Help_View widget displays HTML text.">Fl_Help_View</a>, <a class="el" href="classFl__Scroll.html" title="This container widget lets you maneuver around a set of widgets much larger than your window.">Fl_Scroll</a>, and <a class="el" href="classFl__Text__Display.html" title="Rich text display widget.">Fl_Text_Display</a> widgets. </p>
<dl class="section return"><dt>Returns</dt><dd>The default size for widget scrollbars, in pixels. </dd></dl>

</div>
</div>
<a id="aa6d2b6e0d640b81c6ec44d0164ec0f91" name="aa6d2b6e0d640b81c6ec44d0164ec0f91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6d2b6e0d640b81c6ec44d0164ec0f91">&#9670;&#160;</a></span>scrollbar_size() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Fl::scrollbar_size </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>W</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the default scrollbar size that is used by the <a class="el" href="classFl__Browser__.html" title="This is the base class for browsers.">Fl_Browser_</a>, <a class="el" href="classFl__Help__View.html" title="The Fl_Help_View widget displays HTML text.">Fl_Help_View</a>, <a class="el" href="classFl__Scroll.html" title="This container widget lets you maneuver around a set of widgets much larger than your window.">Fl_Scroll</a>, and <a class="el" href="classFl__Text__Display.html" title="Rich text display widget.">Fl_Text_Display</a> widgets. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">W</td><td>The new default size for widget scrollbars, in pixels. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae41fc4e972e6c2056529e0d393141147" name="ae41fc4e972e6c2056529e0d393141147"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae41fc4e972e6c2056529e0d393141147">&#9670;&#160;</a></span>set_box_color()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Fl::set_box_color </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="Enumerations_8H.html#a8b762953646f8abee866061f1af78a6a">Fl_Color</a>&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the drawing color for the box that is currently drawn. </p>
<p>This method sets the current drawing color <a class="el" href="group__fl__attributes.html#gaea8392e995de663b0d8063af199cf085" title="Returns the last fl_color() that was set.">fl_color()</a> depending on the widget's state to either <code>c</code> or fl_inactive(c).</p>
<p>It should be used whenever a box background is drawn in the box (type) drawing code instead of calling <a class="el" href="group__fl__attributes.html#ga974e9f64959aa83cf6f0a36d3f0105aa" title="Sets the color for all subsequent drawing operations.">fl_color(Fl_Color bg)</a> with the background color <code>bg</code>, usually <a class="el" href="classFl__Widget.html#a0f4654d4d9aab8a1c1078fca5660742a" title="Gets the background color of the widget.">Fl_Widget::color()</a>.</p>
<p>This method is only useful inside box drawing code. Whenever a box is drawn with one of the standard box drawing methods, a static variable is set depending on the widget's current state - if the widget is inactive_r() then the internal variable is false (0), otherwise it is true (1). This is faster than calling <a class="el" href="classFl__Widget.html#a25ebd158cb9f7ccfa7b4cf3406c2b603" title="Returns whether the widget and all of its parents are active.">Fl_Widget::active_r()</a> because the state is cached.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classFl.html#ad56cf568ee94318b50d2b2da0aa3031b" title="Determines if the currently drawn box is active or inactive.">Fl::draw_box_active()</a> </dd>
<dd>
<a class="el" href="classFl.html#aaaecb51f270a5b42ad31f0e8091635dd" title="Gets the drawing color to be used for the background of a box.">Fl::box_color(Fl_Color)</a> </dd></dl>

</div>
</div>
<a id="a77955ad2f2b83fc5e3925b94e4533b20" name="a77955ad2f2b83fc5e3925b94e4533b20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77955ad2f2b83fc5e3925b94e4533b20">&#9670;&#160;</a></span>set_idle()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void Fl::set_idle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__callback__functions.html#ga238786923bf2e91732a7305fc0647dbf">Fl_Old_Idle_Handler</a>&#160;</td>
          <td class="paramname"><em>cb</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets an idle callback. </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000002">Deprecated:</a></b></dt><dd>This method is obsolete - use the <a class="el" href="classFl.html#a4e7a1b5d18c2f073238a8466a62a3e7a" title="Adds a callback function that is called every time by Fl::wait() and also makes it act as though the ...">add_idle()</a> method instead. </dd></dl>

</div>
</div>
<a id="a841e929912f3604e0a3d0ef1dff245c8" name="a841e929912f3604e0a3d0ef1dff245c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a841e929912f3604e0a3d0ef1dff245c8">&#9670;&#160;</a></span>use_high_res_GL() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int Fl::use_high_res_GL </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns whether GL windows should be drawn at high resolution on Apple computers with retina displays. </p>
<p>Default is no. </p><dl class="section version"><dt>Version</dt><dd>1.3.4 </dd></dl>

</div>
</div>
<a id="a3f52e1de14ecab5166a921640fbee640" name="a3f52e1de14ecab5166a921640fbee640"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f52e1de14ecab5166a921640fbee640">&#9670;&#160;</a></span>use_high_res_GL() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void Fl::use_high_res_GL </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>sets whether GL windows should be drawn at high resolution on Apple computers with retina displays </p>
<dl class="section version"><dt>Version</dt><dd>1.3.4 </dd></dl>

</div>
</div>
<a id="ad65803adc5e4936111bd31a52f1d61a7" name="ad65803adc5e4936111bd31a52f1d61a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad65803adc5e4936111bd31a52f1d61a7">&#9670;&#160;</a></span>version()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double Fl::version </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the compiled-in value of the FL_VERSION constant. </p>
<p>This is useful for checking the version of a shared library.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000014">Deprecated:</a></b></dt><dd>Use int <a class="el" href="classFl.html#a7600b0ef3dcd4311850ab4b2988d5d6d" title="Returns the compiled-in value of the FL_API_VERSION constant.">Fl::api_version()</a> instead. </dd></dl>

</div>
</div>
<a id="ae9eaddd02a0aa637078ee2dd80b85b2f" name="ae9eaddd02a0aa637078ee2dd80b85b2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9eaddd02a0aa637078ee2dd80b85b2f">&#9670;&#160;</a></span>visible_focus() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int Fl::visible_focus </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets or sets the visible keyboard focus on buttons and other non-text widgets. </p>
<p>The default mode is to enable keyboard focus for all widgets. </p>

</div>
</div>
<a id="ade5fd097d36257dce2b7aff1165e037f" name="ade5fd097d36257dce2b7aff1165e037f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade5fd097d36257dce2b7aff1165e037f">&#9670;&#160;</a></span>visible_focus() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void Fl::visible_focus </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets or sets the visible keyboard focus on buttons and other non-text widgets. </p>
<p>The default mode is to enable keyboard focus for all widgets. </p>

</div>
</div>
<a id="a6d6deb3d4f76b538d508b36700dfb6b0" name="a6d6deb3d4f76b538d508b36700dfb6b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d6deb3d4f76b538d508b36700dfb6b0">&#9670;&#160;</a></span>visual()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Fl::visual </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Selects a visual so that your graphics are drawn correctly. </p>
<p>This is only allowed before you call show() on any windows. This does nothing if the default visual satisfies the capabilities, or if no visual satisfies the capabilities, or on systems that don't have such brain-dead notions.</p>
<p>Only the following combinations do anything useful:</p>
<ul>
<li>
Fl::visual(FL_RGB) <br  />
Full/true color (if there are several depths FLTK chooses the largest). Do this if you use fl_draw_image for much better (non-dithered) output. <br  />
&#160;  </li>
<li>
Fl::visual(FL_RGB8) <br  />
Full color with at least 24 bits of color. FL_RGB will always pick this if available, but if not it will happily return a less-than-24 bit deep visual. This call fails if 24 bits are not available. <br  />
&#160;  </li>
<li>
<a class="el" href="classFl.html#a6d6deb3d4f76b538d508b36700dfb6b0" title="Selects a visual so that your graphics are drawn correctly.">Fl::visual</a>(FL_DOUBLE|FL_INDEX) <br  />
Hardware double buffering. Call this if you are going to use <a class="el" href="classFl__Double__Window.html" title="The Fl_Double_Window provides a double-buffered window.">Fl_Double_Window</a>. <br  />
&#160;  </li>
<li>
<a class="el" href="classFl.html#a6d6deb3d4f76b538d508b36700dfb6b0" title="Selects a visual so that your graphics are drawn correctly.">Fl::visual</a>(FL_DOUBLE|FL_RGB) </li>
<li>
<a class="el" href="classFl.html#a6d6deb3d4f76b538d508b36700dfb6b0" title="Selects a visual so that your graphics are drawn correctly.">Fl::visual</a>(FL_DOUBLE|FL_RGB8) <br  />
Hardware double buffering and full color. </li>
</ul>
<p>This returns true if the system has the capabilities by default or FLTK suceeded in turing them on. Your program will still work even if this returns false (it just won't look as good). </p>

</div>
</div>
<a id="a108a84216f0b3fa1cb0c46ab7449a312" name="a108a84216f0b3fa1cb0c46ab7449a312"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a108a84216f0b3fa1cb0c46ab7449a312">&#9670;&#160;</a></span>wait()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Fl::wait </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Waits until "something happens" and then returns. </p>
<p>Call this repeatedly to "run" your program. You can also check what happened each time after this returns, which is quite useful for managing program state.</p>
<p>What this really does is call all idle callbacks, all elapsed timeouts, call <a class="el" href="classFl.html#a08d29d807ea3874b8bb16f7457f64bdc" title="Causes all the windows that need it to be redrawn and graphics forced out through the pipes.">Fl::flush()</a> to get the screen to update, and then wait some time (zero if there are idle callbacks, the shortest of all pending timeouts, or infinity), for any events from the user or any <a class="el" href="classFl.html#a799b8278326b3c2db15687c43c11aaf6" title="Adds file descriptor fd to listen to.">Fl::add_fd()</a> callbacks. It then handles the events and calls the callbacks and then returns.</p>
<p>The return value of <a class="el" href="classFl.html#a108a84216f0b3fa1cb0c46ab7449a312" title="Waits until &quot;something happens&quot; and then returns.">Fl::wait()</a> is non-zero if there are any visible windows - this may change in future versions of FLTK.</p>
<p>Fl::wait(time) waits a maximum of <em>time</em> seconds. <em>It can return much sooner if something happens.</em></p>
<p>The return value is positive if an event or fd happens before the time elapsed. It is zero if nothing happens (on Win32 this will only return zero if <em>time</em> is zero). It is negative if an error occurs (this will happen on UNIX if a signal happens). </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a64d41edd7d962116d86a9db810210f7b" name="a64d41edd7d962116d86a9db810210f7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64d41edd7d962116d86a9db810210f7b">&#9670;&#160;</a></span>help</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char *const Fl::help = helpmsg+13</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Usage string displayed if <a class="el" href="classFl.html#a115903daf3593748cdd36a5e78e74534" title="Parse command line switches using the cb argument handler.">Fl::args()</a> detects an invalid argument. </p>
<p>This may be changed to point to customized text at run-time. </p>

</div>
</div>
<a id="a60fb2b446096dd4742511edb459653d3" name="a60fb2b446096dd4742511edb459653d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60fb2b446096dd4742511edb459653d3">&#9670;&#160;</a></span>idle</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void(* Fl::idle)()</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The currently executing idle callback function: DO NOT USE THIS DIRECTLY! </p>
<p>This is now used as part of a higher level system allowing multiple idle callback functions to be called. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classFl.html#a4e7a1b5d18c2f073238a8466a62a3e7a" title="Adds a callback function that is called every time by Fl::wait() and also makes it act as though the ...">add_idle()</a>, <a class="el" href="classFl.html#a43903f998a07e1cca7ba199c8ed25d9b" title="Removes the specified idle callback, if it is installed.">remove_idle()</a> </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="Fl_8H_source.html">Fl.H</a></li>
<li><b>Fl.cxx</b></li>
<li><b>Fl_abort.cxx</b></li>
<li><b>Fl_add_idle.cxx</b></li>
<li><b>Fl_arg.cxx</b></li>
<li><a class="el" href="fl__boxtype_8cxx.html">fl_boxtype.cxx</a></li>
<li><a class="el" href="fl__color_8cxx.html">fl_color.cxx</a></li>
<li><b>fl_color_mac.cxx</b></li>
<li><b>fl_color_win32.cxx</b></li>
<li><a class="el" href="Fl__compose_8cxx.html">Fl_compose.cxx</a></li>
<li><b>Fl_display.cxx</b></li>
<li><b>fl_dnd_win32.cxx</b></li>
<li><a class="el" href="fl__dnd__x_8cxx_source.html">fl_dnd_x.cxx</a></li>
<li><b>Fl_get_key.cxx</b></li>
<li><b>Fl_get_key_mac.cxx</b></li>
<li><b>Fl_get_key_win32.cxx</b></li>
<li><b>Fl_get_system_colors.cxx</b></li>
<li><b>Fl_grab.cxx</b></li>
<li><b>fl_labeltype.cxx</b></li>
<li><b>Fl_lock.cxx</b></li>
<li><b>Fl_own_colormap.cxx</b></li>
<li><b>fl_set_font.cxx</b></li>
<li><b>fl_set_fonts_mac.cxx</b></li>
<li><b>fl_set_fonts_win32.cxx</b></li>
<li><a class="el" href="fl__set__fonts__x_8cxx_source.html">fl_set_fonts_x.cxx</a></li>
<li><b>fl_set_fonts_xft.cxx</b></li>
<li><b>fl_shortcut.cxx</b></li>
<li><b>Fl_visual.cxx</b></li>
<li><b>Fl_Widget.cxx</b></li>
<li><b>Fl_Window.cxx</b></li>
<li><b>gl_start.cxx</b></li>
<li><b>screen_xywh.cxx</b></li>
<li><b>Fl_Cairo.cxx</b></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="classFl.html">Fl</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
